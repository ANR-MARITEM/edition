<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://www.tei-c.org/release/xml/tei/custom/schema/relaxng/tei_odds.rng" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<?xml-model href="http://www.tei-c.org/release/xml/tei/custom/schema/relaxng/tei_odds.rng" type="application/xml" schematypens="http://relaxng.org/ns/structure/1.0"?>
<TEI xmlns:rng="http://relaxng.org/ns/structure/1.0"
    xmlns:sch="http://purl.oclc.org/dsdl/schematron"
    xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns="http://www.tei-c.org/ns/1.0">
    <teiHeader>
        <fileDesc>
            <titleStmt>
                <title>Music Encoding Initiative Guidelines: <title type="sub">All
                    Customization</title></title>
                <respStmt>
                    <resp>Complété par</resp>
                    <name xml:id="PT">Pierre Tuloup</name>
                </respStmt>
            </titleStmt>
            <publicationStmt>
                <p/>
            </publicationStmt>
            <sourceDesc>
                <p/>
            </sourceDesc>
        </fileDesc>
        <revisionDesc>
            <change n="1" when="2021-04-19" who="#PT">
                <desc>Creation of the initial ODD.</desc>
            </change>
        </revisionDesc>
    </teiHeader>
    <text>
        <front>
            <divGen type="toc"/>
        </front>
        <body>
            
            <!-- Limit the set of possible start elements -->
            <schemaSpec ident="mei" ns="http://www.music-encoding.org/ns/mei" prefix="mei_"
                start="mei meiHead meiCorpus music">
                
                <!-- Include all modules -->
                <moduleRef key="MEI"/>
                <classSpec ident="att.notationType" module="MEI" type="atts" mode="add">
                    <desc>Attributes that provide for classification of notation.</desc>
                    <attList org="group">
                        <attDef ident="notationtype" usage="opt">
                            <desc>Contains classification of the notation contained or described by the element bearing this attribute.</desc>
                            <datatype maxOccurs="1" minOccurs="1">
                                <rng:ref name="data.NOTATIONTYPE" />
                            </datatype>
                        </attDef>
                        <attDef ident="notationsubtype" usage="opt">
                            <desc>Provides any sub-classification of the notation contained or described by the element, additional to that given by its notationtype attribute.</desc>
                            <datatype maxOccurs="1" minOccurs="1">
                                <rng:data type="NMTOKEN"/>
                            </datatype>
                            <constraintSpec ident="When_notationsubtype" scheme="schematron">
                                <constraint>
                                    <sch:rule context="mei:*[@notationsubtype]">
                                        <sch:assert test="@notationtype">An element with a notationsubtype attribute must have a notationtype attribute.</sch:assert>
                                    </sch:rule>
                                </constraint>
                            </constraintSpec>
                        </attDef>
                    </attList>
                </classSpec>
                
                <moduleRef key="MEI.shared"
                include="annot body clef clefGrp dot ending group label layer layerDef mdiv mei music note part parts rest score scoreDef 
                section staff staffDef staffGrp tempo"/>
                <elementSpec ident="scoreDef" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.shared">
                    <desc>(score definition) – Container for score meta-information.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.scoreDef.log"/>
                        <memberOf key="att.scoreDef.vis"/>
                        <memberOf key="att.scoreDef.ges"/>
                        <memberOf key="att.scoreDef.anl"/>
                        <memberOf key="model.scoreDefLike"/>
                    </classes>
                    <content>
                        <rng:optional>
                            <rng:ref name="model.chordTableLike" />
                        </rng:optional>
                        <rng:optional>
                            <rng:ref name="model.symbolTableLike" />
                        </rng:optional>
                        <rng:optional>
                            <rng:ref name="model.keySigLike" />
                        </rng:optional>
                        <rng:optional>
                            <rng:ref name="model.meterSigLike" />
                        </rng:optional>
                        <rng:optional>
                            <rng:ref name="pgHead" />
                        </rng:optional>
                        <rng:optional>
                            <rng:ref name="pgHead2" />
                        </rng:optional>
                        <rng:optional>
                            <rng:ref name="pgFoot" />
                        </rng:optional>
                        <rng:optional>
                            <rng:ref name="pgFoot2" />
                        </rng:optional>
                        <rng:optional>
                            <rng:ref name="instrGrp" />
                        </rng:optional>
                        <rng:choice>
                            <rng:optional>
                                <rng:ref name="model.staffGrpLike" />
                            </rng:optional>
                        </rng:choice>
                        <rng:zeroOrMore>
                            <rng:ref name="grpSym" />
                        </rng:zeroOrMore>
                        <rng:optional>
                            <rng:ref name="ambitus" />
                        </rng:optional>
                    </content>
                </elementSpec>
                <elementSpec ident="layer" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.shared">
                    <desc>An independent stream of events on a staff.</desc>
                    <classes>
                        <memberOf key="att.basic"/>
                        <memberOf key="att.facsimile"/>
                        <memberOf key="att.labelled"/>
                        <memberOf key="att.linking"/>
                        <memberOf key="att.metadataPointing"/>
                        <memberOf key="att.nInteger"/>
                        <memberOf key="att.responsibility"/>
                        <memberOf key="att.typed"/>
                        <memberOf key="att.layer.log"/>
                        <memberOf key="att.layer.vis"/>
                        <memberOf key="att.layer.ges"/>
                        <memberOf key="att.layer.anl"/>
                        <memberOf key="model.layerLike"/>
                    </classes>
                    <content>
                        <rng:zeroOrMore>
                            <rng:choice>
                                <rng:ref name="model.annotLike" />
                                <rng:ref name="model.appLike" />
                                <rng:ref name="model.editLike" />
                                <rng:ref name="model.graphicPrimitiveLike" />
                                <rng:ref name="model.layerPart" />
                                <rng:ref name="model.milestoneLike.music" />
                                <rng:ref name="model.transcriptionLike" />
                            </rng:choice>
                        </rng:zeroOrMore>
                    </content>
                    <remarks>
                        <p part="N">The term 'layer' is used instead of 'voice' in order to avoid confusion between 'voice' and 'voice leading' and 'voicing'. The
                            <att scheme="TEI">def</att>
                            attribute may be used to create a connection with a
                            <gi scheme="MEI">layerDef</gi>
                            element where logical and visual information about the layer is recorded. Alternatively, the
                            <att scheme="TEI">n</att>
                            attribute may be used as a reference to a
                            <gi scheme="MEI">layerDef</gi>
                            element with the same value in its
                            <att scheme="TEI">n</att>
                            attribute. If neither
                            <att scheme="TEI">def</att>
                            nor
                            <att scheme="TEI">n</att>
                            attributes are present, then encoding order of the layers is presumed to match the encoding order of the layer definitions.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="staffGrp" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.shared">
                    <desc>(staff group) – A group of bracketed or braced staves.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.facsimile"/>
                        <memberOf key="att.metadataPointing"/>
                        <memberOf key="att.staffGrp.log"/>
                        <memberOf key="att.staffGrp.vis"/>
                        <memberOf key="att.staffGrp.ges"/>
                        <memberOf key="att.staffGrp.anl"/>
                        <memberOf key="model.staffGrpLike"/>
                    </classes>
                    <content>
                        <rng:zeroOrMore>
                            <rng:ref name="grpSym" />
                        </rng:zeroOrMore>
                        <rng:zeroOrMore>
                            <rng:choice>
                                <rng:ref name="model.labelLike" />
                            </rng:choice>
                        </rng:zeroOrMore>
                        <rng:zeroOrMore>
                            <rng:ref name="model.instrDefLike" />
                        </rng:zeroOrMore>
                        <rng:oneOrMore>
                            <rng:choice>
                                <rng:ref name="model.staffGrpLike" />
                                <rng:ref name="model.staffDefLike" />
                            </rng:choice>
                        </rng:oneOrMore>
                        <rng:zeroOrMore>
                            <rng:ref name="grpSym" />
                        </rng:zeroOrMore>
                    </content>
                    <constraintSpec ident="Check_staffGrp_unique_staff_n_values" scheme="schematron">
                        <constraint>
                            <sch:rule context="mei:staffGrp">
                                <sch:let name="countstaves" value="count(descendant::mei:staffDef)"/>
                                <sch:let name="countuniqstaves" value="count(distinct-values(descendant::mei:staffDef/@n))"/>
                                <sch:assert test="$countstaves eq $countuniqstaves">Each staffDef must have a unique value for the n attribute.</sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    <remarks>
                        <p part="N">System is the more proper name for this concept (Read, p. 37-38). Bracketed staff groups may contain other bracketed or braced staff groups or single staves. See Read, p. 35-38, examples p. 434, 438.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="layerDef" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.shared">
                    <desc>(layer definition) – Container for layer meta-information.</desc>
                    <classes>
                        <memberOf key="att.basic"/>
                        <memberOf key="att.labelled"/>
                        <memberOf key="att.linking"/>
                        <memberOf key="att.metadataPointing"/>
                        <memberOf key="att.nInteger"/>
                        <memberOf key="att.responsibility"/>
                        <memberOf key="att.typed"/>
                        <memberOf key="att.layerDef.log"/>
                        <memberOf key="att.layerDef.vis"/>
                        <memberOf key="att.layerDef.ges"/>
                        <memberOf key="att.layerDef.anl"/>
                        <memberOf key="model.layerDefLike"/>
                    </classes>
                    <content>
                        <rng:zeroOrMore>
                            <rng:choice>
                                <rng:ref name="model.labelLike" />
                            </rng:choice>
                        </rng:zeroOrMore>
                        <rng:zeroOrMore>
                            <rng:ref name="model.instrDefLike" />
                        </rng:zeroOrMore>
                        <rng:optional>
                            <rng:ref name="ambitus" />
                        </rng:optional>
                    </content>
                </elementSpec>
                <elementSpec ident="label"  mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.shared">
                    <desc>A container for document text that identifies the feature to which it is attached. For a "tool tip" or other generated label, use the
                        <att scheme="TEI">label</att>
                        attribute.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.facsimile"/>
                        <memberOf key="att.lang"/>
                        <memberOf key="att.source"/>
                        <memberOf key="model.labelLike"/>
                    </classes>
                    <content>
                        <rng:zeroOrMore>
                            <rng:choice>
                                <rng:text/>
                                <rng:ref name="model.textPhraseLike.limited" />
                                <rng:ref name="model.editLike" />
                                <rng:ref name="model.transcriptionLike" />
                            </rng:choice>
                        </rng:zeroOrMore>
                    </content>
                    <remarks>
                        <p part="N">This element is modelled on an element in the Text Encoding Initiative (TEI) standard.</p>
                        <p part="N">Don't confuse this element, which is used to capture labelling text appearing in the document, with the
                            <att scheme="TEI">label</att>
                            attribute, which records text to be used to generate a designation for the element to which it's attached, a "tool tip" or prefatory text, for example.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="staffDef" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.shared">
                    <desc>(staff definition) – Container for staff meta-information.</desc>
                    <classes>
                        <memberOf key="att.basic"/>
                        <memberOf key="att.labelled"/>
                        <memberOf key="att.linking"/>
                        <memberOf key="att.metadataPointing"/>
                        <memberOf key="att.nInteger"/>
                        <memberOf key="att.responsibility"/>
                        <memberOf key="att.typed"/>
                        <memberOf key="att.staffDef.log"/>
                        <memberOf key="att.staffDef.vis"/>
                        <memberOf key="att.staffDef.ges"/>
                        <memberOf key="att.staffDef.anl"/>
                        <memberOf key="model.staffDefLike"/>
                    </classes>
                    <content>
                        <rng:zeroOrMore>
                            <rng:choice>
                                <rng:ref name="model.labelLike" />
                            </rng:choice>
                        </rng:zeroOrMore>
                        <rng:zeroOrMore>
                            <rng:choice>
                                <rng:ref name="model.instrDefLike" />
                                <rng:ref name="model.layerDefLike" />
                                <rng:ref name="model.staffDefPart" />
                            </rng:choice>
                        </rng:zeroOrMore>
                        <rng:optional>
                            <rng:ref name="ambitus" />
                        </rng:optional>
                    </content>
                    <constraintSpec ident="Check_staffDefn" scheme="schematron">
                        <constraint>
                            <sch:rule context="mei:staffDef[not(ancestor::mei:staff)]">
                                <sch:let name="thisstaff" value="@n"/>
                                <sch:assert test="@n">StaffDef must have an n attribute.</sch:assert>
                                <sch:assert test="@lines or preceding::mei:staffDef[@n=$thisstaff and @lines]"> Either @lines must be present or a preceding staffDef with the same value for @n and @lines must exist.</sch:assert>
                                <sch:assert test="count(mei:clef) + count(mei:clefGrp) 2">Only one clef or clefGrp is permitted.</sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    <constraintSpec ident="Check_ancestor_staff" scheme="schematron">
                        <constraint>
                            <sch:rule context="mei:staffDef[ancestor::mei:staff and @n]">
                                <sch:let name="thisstaff" value="@n"/>
                                <sch:assert test="ancestor::mei:staff/@n eq $thisstaff">@n must have the same value as the current staff.</sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    <constraintSpec ident="Check_ancestor_staff_lines" scheme="schematron">
                        <constraint>
                            <sch:rule context="mei:staffDef[ancestor::mei:staff and not(@n)]">
                                <sch:let name="thisstaff" value="ancestor::mei:staff/@n"/>
                                <sch:assert test="@lines or preceding::mei:staffDef[@n=$thisstaff and @lines]"> Either @lines must be present or a preceding staffDef with matching @n value and @lines must exist.</sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    <constraintSpec ident="Check_clef_position_staffDef" scheme="schematron">
                        <constraint>
                            <sch:rule context="mei:staffDef[@clef.line and @lines]">
                                <sch:assert test="number(@clef.line) = number(@lines)">The clef position must be less than or equal to the number of lines on the staff.</sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    <constraintSpec ident="Check_clef_position_staffDef_nolines" scheme="schematron">
                        <constraint>
                            <sch:rule context="mei:staffDef[@clef.line and not(@lines)]">
                                <sch:let name="thisstaff" value="@n"/>
                                <sch:let name="stafflines" value="preceding::mei:staffDef[@n=$thisstaff and @lines][1]/@lines"/>
                                <sch:assert test="number(@clef.line) = number($stafflines)">The clef position must be less than or equal to the number of lines on the staff.</sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    <constraintSpec ident="Check_tab_strings_lines" scheme="schematron">
                        <constraint>
                            <sch:rule context="mei:staffDef[@tab.strings and @lines]">
                                <sch:let name="countTokens" value="count(tokenize(normalize-space(@tab.strings), '\s'))"/>
                                <sch:assert test="$countTokens = @lines">The tab.strings attribute must have the same number of values as there are staff lines.</sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    <constraintSpec ident="Check_tab_strings_nolines" scheme="schematron">
                        <constraint>
                            <sch:rule context="mei:staffDef[@tab.strings and not(@lines)]">
                                <sch:let name="countTokens" value="count(tokenize(normalize-space(@tab.strings), '\s'))"/>
                                <sch:let name="thisstaff" value="@n"/>
                                <sch:assert test="$countTokens = preceding::mei:staffDef[@n=$thisstaff and @lines][1]/@lines">The tab.strings attribute must have the same number of values as there are staff lines.</sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    <constraintSpec ident="Check_lines_color" scheme="schematron">
                        <constraint>
                            <sch:pattern>
                                <sch:rule context="mei:staffDef[@lines.color and @lines]">
                                    <sch:let name="countTokens" value="count(tokenize(normalize-space(@lines.color), '\s'))"/>
                                    <sch:assert test="$countTokens = 1 or $countTokens = @lines">The lines.color attribute must have either 1) a single value or 2) the same number of values as there are staff lines.</sch:assert>
                                </sch:rule>
                                <sch:rule context="mei:staffDef[@lines.color and not(@lines)]">
                                    <sch:let name="countTokens" value="count(tokenize(normalize-space(@lines.color), '\s'))"/>
                                    <sch:let name="thisstaff" value="@n"/>
                                    <sch:assert test="$countTokens = 1 or $countTokens = preceding::mei:staffDef[@n=$thisstaff and @lines][1]/@lines">The lines.color attribute must have either 1) a single value or 2) the same number of values as there are staff lines.</sch:assert>
                                </sch:rule>
                            </sch:pattern>
                        </constraint>
                    </constraintSpec>
                    <constraintSpec ident="Check_staff_ppq_ancestor" scheme="schematron">
                        <constraint>
                            <sch:pattern>
                                <sch:rule context="mei:staffDef[@ppq][ancestor::mei:scoreDef[@ppq]]">
                                    <sch:let name="staffPPQ" value="@ppq"/>
                                    <sch:let name="scorePPQ" value="ancestor::mei:scoreDef[@ppq][1]/@ppq"/>
                                    <sch:assert test="($scorePPQ mod $staffPPQ) = 0">The value of ppq must be a factor of the value of ppq on an ancestor scoreDef.</sch:assert>
                                </sch:rule>
                            </sch:pattern>
                        </constraint>
                    </constraintSpec>
                    <constraintSpec ident="Check_staff_ppq_preceding" scheme="schematron">
                        <constraint>
                            <sch:pattern>
                                <sch:rule context="mei:staffDef[@ppq][preceding::mei:scoreDef[@ppq]]">
                                    <sch:let name="staffPPQ" value="@ppq"/>
                                    <sch:let name="scorePPQ" value="preceding::mei:scoreDef[@ppq][1]/@ppq"/>
                                    <sch:assert test="($scorePPQ mod $staffPPQ) = 0">The value of ppq must be a factor of the value of ppq on a preceding scoreDef.</sch:assert>
                                </sch:rule>
                            </sch:pattern>
                        </constraint>
                    </constraintSpec>
                </elementSpec>
                <elementSpec ident="staff" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.shared">
                    <desc>A group of equidistant horizontal lines on which notes are placed in order to represent pitch or a grouping element for individual 'strands' of notes, rests, etc. that may or may not actually be rendered on staff lines; that is, both diastematic and non-diastematic signs.</desc>
                    <classes>
                        <memberOf key="att.basic"/>
                        <memberOf key="att.facsimile"/>
                        <memberOf key="att.labelled"/>
                        <memberOf key="att.linking"/>
                        <memberOf key="att.metadataPointing"/>
                        <memberOf key="att.nInteger"/>
                        <memberOf key="att.responsibility"/>
                        <memberOf key="att.typed"/>
                        <memberOf key="att.staff.log"/>
                        <memberOf key="att.staff.vis"/>
                        <memberOf key="att.staff.ges"/>
                        <memberOf key="att.staff.anl"/>
                        <memberOf key="model.staffLike"/>
                    </classes>
                    <content>
                        <rng:zeroOrMore>
                            <rng:choice>
                                <rng:ref name="model.annotLike" />
                                <rng:ref name="model.appLike" />
                                <rng:ref name="model.editLike" />
                                <rng:ref name="model.graphicPrimitiveLike" />
                                <rng:ref name="model.milestoneLike.music" />
                                <rng:ref name="model.relationLike" />
                                <rng:ref name="model.staffDefLike" />
                                <rng:ref name="model.staffPart" />
                                <rng:ref name="model.transcriptionLike" />
                            </rng:choice>
                        </rng:zeroOrMore>
                    </content>
                    <constraintSpec ident="checkStaff_n" scheme="schematron">
                        <constraint>
                            <sch:rule context="mei:staff[@n]">
                                <sch:let name="thisstaff" value="@n"/>
                                <sch:assert test="preceding::mei:staffDef[@n=$thisstaff] or preceding::mei:staff[@n=$thisstaff]/mei:staffDef or mei:staffDef">There must be a preceding staffDef with a matching value of @n, a preceding staff with a matching @n value containing a staffDef, or a staffDef child element.</sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    <remarks>
                        <p part="N">The
                            <att scheme="TEI">def</att>
                            attribute may be used to create a connection with a
                            <gi scheme="MEI">staffDef</gi>
                            element where logical and visual information about the staff is recorded. Alternatively, the
                            <att scheme="TEI">n</att>
                            attribute may be used as a reference to a
                            <gi scheme="MEI">staffDef</gi>
                            element with the same value in its
                            <att scheme="TEI">n</att>
                            attribute or the staff may contain a staffDef element that defines it. If neither
                            <att scheme="TEI">def</att>
                            nor
                            <att scheme="TEI">n</att>
                            attributes are present, then the encoding order of the staves is presumed to match the encoding order of the staff definitions.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="score" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.shared">
                    <desc>Full score view of the musical content.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.metadataPointing"/>
                        <memberOf key="att.score.log"/>
                        <memberOf key="att.score.vis"/>
                        <memberOf key="att.score.ges"/>
                        <memberOf key="att.score.anl"/>
                        <memberOf key="model.scoreLike"/>
                    </classes>
                    <content>
                        <rng:zeroOrMore>
                            <rng:choice>
                                <rng:ref name="model.annotLike" />
                                <rng:ref name="model.appLike" />
                                <rng:ref name="model.divLike" />
                                <rng:ref name="model.editLike" />
                                <rng:ref name="model.graphicPrimitiveLike" />
                                <rng:ref name="model.milestoneLike.music" />
                                <rng:ref name="model.relationLike" />
                                <rng:ref name="model.scoreDefLike" />
                                <rng:ref name="model.scorePart" />
                                <rng:ref name="model.staffDefLike" />
                                <rng:ref name="model.transcriptionLike" />
                            </rng:choice>
                        </rng:zeroOrMore>
                    </content>
                    <remarks>
                        <p part="N">Since the
                            <gi scheme="MEI">measure</gi>
                            element is optional, a score may consist entirely of page beginnings, each of which points to a page image.
                            <gi scheme="MEI">div</gi>
                            elements are allowed preceding and following sections of music data in order to accommodate blocks of explanatory text.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="note" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.shared">
                    <desc>A single pitched event. </desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.facsimile"/>
                        <memberOf key="att.note.log"/>
                        <memberOf key="att.note.vis"/>
                        <memberOf key="att.note.ges"/>
                        <memberOf key="att.note.anl"/>
                        <memberOf key="model.chordPart"/>
                        <memberOf key="model.eventLike"/>
                    </classes>
                    <content>
                        <rng:zeroOrMore>
                            <rng:choice>
                                <rng:ref name="model.noteModifierLike" />
                                <rng:ref name="model.verseLike" />
                                <rng:ref name="model.sylLike" />
                                <rng:ref name="model.appLike" />
                                <rng:ref name="model.editLike" />
                                <rng:ref name="model.transcriptionLike" />
                            </rng:choice>
                        </rng:zeroOrMore>
                    </content>
                    <remarks>
                        <p part="N">The
                            <gi scheme="MEI">accid</gi>
                            and
                            <gi scheme="MEI">artic</gi>
                            sub-elements may be used instead of the note element's attributes when accid and artic represent first-class objects, e.g., when they require attributes, such as
                            <att scheme="TEI">x</att>
                            and
                            <att scheme="TEI">y</att>
                            location attributes. Similarly, the
                            <gi scheme="MEI">syl</gi>
                            sub-element may be used instead of the
                            <att scheme="TEI">syl</att>
                            attribute. The verse sub-element may be used to group text syllables by verse. The
                            <att scheme="TEI">colored</att>
                            attribute may be used to indicate coloration. In the mensural repertoire, coloration is a temporary change in the underlying mensuration from perfect to imperfect. In the CMN repertoire, coloration is an inversion of the note head's normal rendition, that is, the note head is void when it would otherwise be filled and vice versa. Do not confuse this with visual color.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="annot" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.shared">
                    <desc>(annotation) – Provides a statement explaining the text or indicating the basis for an assertion.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.annot.log"/>
                        <memberOf key="att.annot.vis"/>
                        <memberOf key="att.annot.ges"/>
                        <memberOf key="att.annot.anl"/>
                        <memberOf key="att.audience"/>
                        <memberOf key="att.bibl"/>
                        <memberOf key="att.dataPointing"/>
                        <memberOf key="att.facsimile"/>
                        <memberOf key="att.lang"/>
                        <memberOf key="att.plist"/>
                        <memberOf key="att.source"/>
                        <memberOf key="att.targetEval"/>
                        <memberOf key="model.annotLike"/>
                    </classes>
                    <content>
                        <rng:choice>
                            <rng:group>
                                <rng:zeroOrMore>
                                    <rng:ref name="model.headLike" />
                                </rng:zeroOrMore>
                                <rng:zeroOrMore>
                                    <rng:ref name="model.textComponentLike" />
                                </rng:zeroOrMore>
                            </rng:group>
                            <rng:zeroOrMore>
                                <rng:choice>
                                    <rng:text/>
                                    <rng:ref name="model.editLike" />
                                    <rng:ref name="model.textPhraseLike" />
                                    <rng:ref name="model.transcriptionLike" />
                                </rng:choice>
                            </rng:zeroOrMore>
                        </rng:choice>
                    </content>
                    <constraintSpec ident="Check_annot_data" scheme="schematron">
                        <constraint>
                            <sch:rule context="mei:annot[@data]">
                                <sch:assert test="ancestor::mei:notesStmt">The @data attribute may only occur on an annotation within the notesStmt element.</sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    <remarks>
                        <p part="N">The
                            <gi scheme="MEI">annot</gi>
                            element can be used for both general comments and for annotations of the musical text. It provides a way to group participating *events* and/or *control events*, for example, the notes that form a descending bass line, and provide a label for and comment regarding the group. Participating entities may be identified in the
                            <att scheme="TEI">plist</att>
                            attribute. An editorial or analytical comment or observation may be included directly within the
                            <gi scheme="MEI">annot</gi>
                            element. The starting point of the annotation may be indicated by either a
                            <att scheme="TEI">tstamp</att>
                            ,
                            <att scheme="TEI">tstamp.ges</att>
                            ,
                            <att scheme="TEI">tstamp.real</att>
                            or
                            <att scheme="TEI">startid</att>
                            attribute, while the ending point may be recorded by either a
                            <att scheme="TEI">dur</att>
                            ,
                            <att scheme="TEI">dur.ges</att>
                            or
                            <att scheme="TEI">endid</att>
                            attribute. The
                            <att scheme="TEI">resp</att>
                            attribute records the editor(s) responsible for identifying or creating the annotation.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="rest" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.shared">
                    <desc>A non-sounding event found in the source being transcribed.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.facsimile"/>
                        <memberOf key="att.rest.log"/>
                        <memberOf key="att.rest.vis"/>
                        <memberOf key="att.rest.ges"/>
                        <memberOf key="att.rest.anl"/>
                        <memberOf key="model.eventLike"/>
                    </classes>
                    <content>
                        <rng:zeroOrMore>
                            <rng:choice>
                                <rng:ref name="dot" />
                                <rng:ref name="model.appLike" />
                                <rng:ref name="model.editLike" />
                                <rng:ref name="model.transcriptionLike" />
                            </rng:choice>
                        </rng:zeroOrMore>
                    </content>
                    <constraintSpec ident="Check_restline" scheme="schematron">
                        <constraint>
                            <sch:rule context="mei:rest[@line]">
                                <sch:let name="thisstaff" value="ancestor::mei:staff/@n"/>
                                <sch:assert test="number(@line) = number(preceding::mei:staffDef[@n=$thisstaff and @lines][1]/@lines)">The value of @line must be less than or equal to the number of lines on the staff.</sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    <remarks>
                        <p part="N">See (Read, p. 96-102). Do not confuse this element with the
                            <gi scheme="MEI">space</gi>
                            element, which is used as an aid for visual alignment.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="section" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.shared">
                    <desc>Segment of music data.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.facsimile"/>
                        <memberOf key="att.metadataPointing"/>
                        <memberOf key="att.pointing"/>
                        <memberOf key="att.section.anl"/>
                        <memberOf key="att.section.ges"/>
                        <memberOf key="att.section.log"/>
                        <memberOf key="att.section.vis"/>
                        <memberOf key="att.targetEval"/>
                        <memberOf key="model.sectionLike"/>
                    </classes>
                    <content>
                        <rng:zeroOrMore>
                            <rng:ref name="expansion" />
                        </rng:zeroOrMore>
                        <rng:zeroOrMore>
                            <rng:choice>
                                <rng:ref name="model.annotLike" />
                                <rng:ref name="model.appLike" />
                                <rng:ref name="model.divLike" />
                                <rng:ref name="model.editLike" />
                                <rng:ref name="model.graphicPrimitiveLike" />
                                <rng:ref name="model.milestoneLike.music" />
                                <rng:ref name="model.relationLike" />
                                <rng:ref name="model.sectionPart" />
                                <rng:ref name="model.transcriptionLike" />
                            </rng:choice>
                        </rng:zeroOrMore>
                    </content>
                    <constraintSpec ident="Check_sectionexpansion" scheme="schematron">
                        <constraint>
                            <sch:rule context="mei:section[mei:expansion]">
                                <sch:assert test="descendant::mei:section|descendant::mei:ending|descendant::mei:rdg">A section containing an expansion element must have descendant section, ending, or rdg elements.</sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    <remarks>
                        <p part="N">This element functions as a container for actual music data. Pointing attributes make it possible to connect this element to other internal or external entities, such as media objects or annotations.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="parts" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.shared">
                    <desc>Provides a container for performers' parts.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.metadataPointing"/>
                        <memberOf key="att.parts.log"/>
                        <memberOf key="att.parts.vis"/>
                        <memberOf key="att.parts.ges"/>
                        <memberOf key="att.parts.anl"/>
                        <memberOf key="model.partsLike"/>
                    </classes>
                    <content>
                        <rng:zeroOrMore>
                            <rng:ref name="model.partLike" />
                        </rng:zeroOrMore>
                    </content>
                </elementSpec>
                <elementSpec ident="part" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.shared">
                    <desc>An alternative visual rendition of the score from the point of view of a particular performer (or group of performers).</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.metadataPointing"/>
                        <memberOf key="att.part.log"/>
                        <memberOf key="att.part.vis"/>
                        <memberOf key="att.part.ges"/>
                        <memberOf key="att.part.anl"/>
                        <memberOf key="model.partLike"/>
                    </classes>
                    <content>
                        <rng:zeroOrMore>
                            <rng:choice>
                                <rng:ref name="model.annotLike" />
                                <rng:ref name="model.appLike" />
                                <rng:ref name="model.divLike" />
                                <rng:ref name="model.editLike" />
                                <rng:ref name="model.graphicPrimitiveLike" />
                                <rng:ref name="model.milestoneLike.music" />
                                <rng:ref name="model.scoreDefLike" />
                                <rng:ref name="model.scorePart" />
                                <rng:ref name="model.staffDefLike" />
                                <rng:ref name="model.transcriptionLike" />
                            </rng:choice>
                        </rng:zeroOrMore>
                    </content>
                    <remarks>
                        <p part="N">
                            <gi scheme="MEI">part</gi>
                            elements are not used in MEI to indicate voice leading.
                            <att scheme="TEI">next</att>
                            attributes on event elements should be used for this purpose.
                            <gi scheme="MEI">part</gi>
                            elements are useful for encoding individual parts when there is no score, such as early music part books, when the music has non-aligning bar lines, when different layout, such as page turns, are needed for the score and parts, or for accommodating software that requires part-by-part encoding. When assembly of the parts into a score is desired and there are non-aligning bar lines, bar lines which indicate points of alignment across all the parts may be marked as 'controlling', while non-aligning ones may be marked as 'non-controlling'.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="mdiv" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.shared">
                    <desc>(musical division) – Contains a subdivision of the body of a musical text.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.facsimile"/>
                        <memberOf key="att.metadataPointing"/>
                        <memberOf key="att.mdiv.anl"/>
                        <memberOf key="att.mdiv.ges"/>
                        <memberOf key="att.mdiv.log"/>
                        <memberOf key="att.mdiv.vis"/>
                        <memberOf key="model.mdivLike"/>
                    </classes>
                    <content>
                        <rng:choice>
                            <rng:group>
                                <rng:optional>
                                    <rng:ref name="model.scoreLike" />
                                </rng:optional>
                                <rng:optional>
                                    <rng:ref name="model.partsLike" />
                                </rng:optional>
                            </rng:group>
                            <rng:zeroOrMore>
                                <rng:ref name="model.mdivLike" />
                            </rng:zeroOrMore>
                        </rng:choice>
                    </content>
                    <remarks>
                        <p part="N">The
                            <gi scheme="MEI">mdiv</gi>
                            element may contain one or both of 2 possible views of the music. The score view is the traditional full and open score while the parts view contains each performer's view of the score; that is, his part. These 2 views are necessary because it is not always possible or desirable to generate one from the other. The
                            <gi scheme="MEI">score</gi>
                            and
                            <gi scheme="MEI">parts</gi>
                            elements are placed here and not directly within the
                            <gi scheme="MEI">body</gi>
                            element because score and part characteristics may change from
                            <gi scheme="MEI">mdiv</gi>
                            to
                            <gi scheme="MEI">mdiv</gi>
                            . For example, the 2nd movement of a symphony may require different performing forces (and therefore different score and part layout) than the other movements. The
                            <gi scheme="MEI">mdiv</gi>
                            element may be recursively nested in order to represent music which exhibits this kind of structure. For example, an opera is normally divided into acts, which are in turn divided into scenes.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="body" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.shared">
                    <desc>Contains the whole of a single musical text, excluding any front or back matter.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.metadataPointing"/>
                        <memberOf key="model.musicPart"/>
                    </classes>
                    <content>
                        <rng:oneOrMore>
                            <rng:choice>
                                <rng:ref name="model.divLike" />
                                <rng:ref name="model.mdivLike" />
                            </rng:choice>
                        </rng:oneOrMore>
                    </content>
                    <remarks>
                        <p part="N">When the music can be broken into high-level, discrete, linear segments, such as movements of a symphony, there may be multiple
                            <gi scheme="MEI">mdiv</gi>
                            elements within
                            <gi scheme="MEI">body</gi>
                            . This is the highest level indication of the structure of the music.</p>
                        <p part="N">The content model of
                            <gi scheme="MEI">body</gi>
                            also allows blocks of text and music notation to be interleaved. This permits the encoding of a wide range of musical documents, including those that are primarily textual with only occasional musical material or even those which completely lack music notation.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="music" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.shared">
                    <desc>Contains a single musical text of any kind, whether unitary or composite, for example, an etude, opera, song cycle, symphony, or anthology of piano solos.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.meiVersion"/>
                        <memberOf key="att.metadataPointing"/>
                    </classes>
                    <content>
                        <rng:zeroOrMore>
                            <rng:ref name="model.resourceLike" />
                        </rng:zeroOrMore>
                        <rng:ref name="macro.musicPart" />
                    </content>
                </elementSpec>
                <elementSpec ident="mei" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.shared">
                    <desc>Contains a single MEI-conformant document, consisting of an MEI header and a musical text, either in isolation or as part of an meiCorpus element.</desc>
                    <classes>
                        <memberOf key="att.id"/>
                        <memberOf key="att.meiVersion"/>
                        <memberOf key="att.responsibility"/>
                    </classes>
                    <content>
                        <rng:ref name="meiHead" />
                        <rng:ref name="music" />
                    </content>
                    <constraintSpec ident="Check_staff" scheme="schematron">
                        <constraint>
                            <sch:rule context="mei:*[@staff]">
                                <sch:assert test="every $i in tokenize(normalize-space(@staff), '\s+') satisfies $i=//mei:staffDef/@n">The values in @staff must correspond to @n attribute of a staffDef element.</sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    <remarks>
                        <p part="N">The
                            <gi scheme="MEI">mei</gi>
                            element defines an instance of a document encoded with the MEI schema. It is the document element for a single document containing a header and data. The name of this element should not be changed by any customization in order to assure an absolute minimum level of MEI compliance.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="group" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.shared">
                    <desc>Contains a composite musical text, grouping together a sequence of distinct musical texts (or groups of such musical texts) which are regarded as a unit for some purpose, for example, the collected works of a composer.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.metadataPointing"/>
                        <memberOf key="model.musicPart"/>
                    </classes>
                    <content>
                        <rng:choice>
                            <rng:ref name="music" />
                            <rng:ref name="group" />
                        </rng:choice>
                        <rng:zeroOrMore>
                            <rng:choice>
                                <rng:ref name="music" />
                                <rng:ref name="group" />
                            </rng:choice>
                        </rng:zeroOrMore>
                    </content>
                    <remarks>
                        <p part="N">Because its model contains the music element, each of the subordinate MEI documents can have its own front and back matter.</p>
                    </remarks>
                    <remarks>
                        <p part="N">This element is modelled on an element in the Text Encoding Initiative (TEI) standard.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="ending" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.shared">
                    <desc>Alternative ending for a repeated passage of music; i.e., prima volta, seconda volta, etc.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.ending.anl"/>
                        <memberOf key="att.ending.ges"/>
                        <memberOf key="att.ending.log"/>
                        <memberOf key="att.ending.vis"/>
                        <memberOf key="att.facsimile"/>
                        <memberOf key="att.pointing"/>
                        <memberOf key="att.targetEval"/>
                        <memberOf key="model.endingLike"/>
                    </classes>
                    <content>
                        <rng:zeroOrMore>
                            <rng:ref name="expansion" />
                        </rng:zeroOrMore>
                        <rng:zeroOrMore>
                            <rng:choice>
                                <rng:ref name="model.annotLike" />
                                <rng:ref name="model.appLike" />
                                <rng:ref name="model.editLike" />
                                <rng:ref name="model.graphicPrimitiveLike" />
                                <rng:ref name="model.milestoneLike.music" />
                                <rng:ref name="model.relationLike" />
                                <rng:ref name="model.scoreDefLike" />
                                <rng:ref name="model.sectionLike" />
                                <rng:ref name="model.sectionPart.cmn" />
                                <rng:ref name="model.sectionPart.mensuralAndNeumes" />
                                <rng:ref name="model.staffDefLike" />
                                <rng:ref name="model.transcriptionLike" />
                            </rng:choice>
                        </rng:zeroOrMore>
                    </content>
                    <remarks>
                        <p part="N">The
                            <gi scheme="MEI">scoreDef</gi>
                            element is allowed as a sub-element so that an ending may have its own meta-data without the overhead of child
                            <gi scheme="MEI">section</gi>
                            elements.
                            <gi scheme="MEI">div</gi>
                            sub-elements are not allowed within ending. They may, however, be contained by the children of ending, e.g., measures. Endings may not contain other ending elements.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="clef" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.shared">
                    <desc>Indication of the exact location of a particular note on the staff and, therefore, the other notes as well.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.event"/>
                        <memberOf key="att.facsimile"/>
                        <memberOf key="att.clef.anl"/>
                        <memberOf key="att.clef.ges"/>
                        <memberOf key="att.clef.log"/>
                        <memberOf key="att.clef.vis"/>
                        <memberOf key="model.eventLike"/>
                        <memberOf key="model.staffDefPart"/>
                    </classes>
                    <content>
                        <rng:empty/>
                    </content>
                    <constraintSpec ident="Clef_position_lines" scheme="schematron">
                        <constraint>
                            <sch:rule context="mei:clef[ancestor::mei:staffDef[@lines]]">
                                <sch:let name="thisstaff" value="ancestor::mei:staffDef/@n"/>
                                <sch:assert test="number(@line) = number(ancestor::mei:staffDef[@n=$thisstaff and @lines][1]/@lines)">The clef position must be less than or equal to the number of lines of an ancestor staff.</sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    <constraintSpec ident="Clef_position_nolines" scheme="schematron">
                        <constraint>
                            <sch:rule context="mei:clef[ancestor::mei:staffDef[not(@lines)]]">
                                <sch:let name="thisstaff" value="ancestor::mei:staffDef/@n"/>
                                <sch:assert test="number(@line) = number(preceding::mei:staffDef[@n=$thisstaff and @lines][1]/@lines)">The clef position must be less than or equal to the number of lines of a preceding staff.</sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    <remarks>
                        <p part="N">This element can be used as an alternative to the
                            <gi scheme="MEI">staff</gi>
                            element's clef.* attributes. It should be used when specific display info, such as size or color, needs to be recorded for the clef or when multiple, simultaneous clefs occur on a single staff. This element may also be used within the staff context to indicate changes of clef.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="clefGrp" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.shared">
                    <desc>(clef group) – A set of simultaneously-occurring clefs.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.event"/>
                        <memberOf key="att.facsimile"/>
                        <memberOf key="att.clefGrp.log"/>
                        <memberOf key="att.clefGrp.vis"/>
                        <memberOf key="att.clefGrp.ges"/>
                        <memberOf key="att.clefGrp.anl"/>
                        <memberOf key="model.eventLike"/>
                        <memberOf key="model.staffDefPart"/>
                    </classes>
                    <content>
                        <rng:oneOrMore>
                            <rng:ref name="clef" />
                        </rng:oneOrMore>
                    </content>
                </elementSpec>
                <elementSpec ident="tempo" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.shared">
                    <desc>Text and symbols descriptive of tempo, mood, or style, e.g., "allarg.", "a tempo", "cantabile", "Moderato", "♩=60", "Moderato ♩ =60").</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.bibl"/>
                        <memberOf key="att.facsimile"/>
                        <memberOf key="att.lang"/>
                        <memberOf key="att.tempo.log"/>
                        <memberOf key="att.tempo.vis"/>
                        <memberOf key="att.tempo.ges"/>
                        <memberOf key="att.tempo.anl"/>
                        <memberOf key="model.controlEventLike"/>
                        <memberOf key="model.workIdent"/>
                    </classes>
                    <content>
                        <rng:zeroOrMore>
                            <rng:choice>
                                <rng:text/>
                                <rng:ref name="model.textPhraseLike.limited" />
                                <rng:ref name="model.graphicPrimitiveLike" />
                                <rng:ref name="model.editLike" />
                                <rng:ref name="model.transcriptionLike" />
                            </rng:choice>
                        </rng:zeroOrMore>
                    </content>
                    <constraintSpec ident="tempo_in_header_disallow_most_attrs" scheme="schematron">
                        <constraint>
                            <sch:rule context="mei:tempo[not(ancestor::mei:score or ancestor::mei:part)]">
                                <sch:assert test="not(@*[name() != 'analog' and name() != 'class' and name() != 'label' and name() != 'mm' and name() != 'mm.dots' and name() != 'translit' and name() != 'type' and name() != 'mm.unit' and name() != 'n' and name() != 'xml:base' and name() != 'xml:id' and name() != 'xml:lang'])">Only analog, class, label, mm, mm.dots, mm.unit, n, translit, type, xml:base, xml:id, and xml:lang attributes are allowed when tempo is not a descendant of a score or part.</sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    <constraintSpec ident="tempo_start-type_attributes_required" scheme="schematron">
                        <constraint>
                            <sch:rule context="mei:tempo[not(ancestor::mei:syllable) and not(ancestor::mei:work) and not(ancestor::mei:expression) and not(count(ancestor::mei:*) = 0)]">
                                <sch:assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one of the attributes: startid, tstamp, tstamp.ges or tstamp.real.</sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                </elementSpec>
                <elementSpec ident="dot" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.shared">
                    <desc>Dot of augmentation or division.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.facsimile"/>
                        <memberOf key="att.dot.log"/>
                        <memberOf key="att.dot.vis"/>
                        <memberOf key="att.dot.ges"/>
                        <memberOf key="att.dot.anl"/>
                        <memberOf key="model.noteModifierLike"/>
                    </classes>
                    <content>
                        <rng:empty/>
                    </content>
                    <remarks>
                        <p part="N">This element provides an alternative to the
                            <att scheme="TEI">dots</att>
                            attribute on
                            <gi scheme="MEI">note</gi>
                            and
                            <gi scheme="MEI">rest</gi>
                            elements. It should be used when specific display info, such as size or color, needs to be recorded for the dot. This element may also be used for dots of division in the mensural repertoire.</p>
                    </remarks>
                </elementSpec>
                
                <classSpec ident="att.octave" module="MEI.shared" type="atts" mode="add">
                    <desc>Attributes that record written octave.</desc>
                    <attList org="group">
                        <attDef ident="oct" usage="opt">
                            <desc>Captures written octave information.</desc>
                            <datatype maxOccurs="1" minOccurs="1">
                                <rng:ref name="data.OCTAVE" />
                            </datatype>
                        </attDef>
                    </attList>
                </classSpec>
                <classSpec ident="att.common" module="MEI.shared" type="atts" mode="add">
                    <desc>Attributes common to many elements.</desc>
                    <classes>
                        <memberOf key="att.basic"/>
                        <memberOf key="att.labelled"/>
                        <memberOf key="att.linking"/>
                        <memberOf key="att.nNumberLike"/>
                        <memberOf key="att.responsibility"/>
                        <memberOf key="att.typed"/>
                    </classes>
                </classSpec>
                <classSpec ident="att.basic" module="MEI.shared" type="atts" mode="add">
                    <desc>Attributes that form the basis of the att.common class.</desc>
                    <classes>
                        <memberOf key="att.id"/>
                    </classes>
                    <attList org="group">
                        <attDef ident="xml:base" usage="opt">
                            <desc>Provides a base URI reference with which applications can resolve relative URI references into absolute URI references.</desc>
                            <datatype maxOccurs="1" minOccurs="1">
                                <rng:ref name="data.URI" />
                            </datatype>
                        </attDef>
                    </attList>
                </classSpec>
                <classSpec ident="att.id" module="MEI.shared" type="atts" mode="add">
                    <desc>Attributes that uniquely identify an element.</desc>
                    <attList org="group">
                        <attDef ident="xml:id" usage="opt">
                            <desc>Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.</desc>
                            <datatype maxOccurs="1" minOccurs="1">
                                <rng:data type="ID"/>
                            </datatype>
                        </attDef>
                    </attList>
                </classSpec>
                <classSpec ident="att.labelled" module="MEI.shared" type="atts" mode="add">
                    <attList org="group">
                        <attDef ident="label" usage="opt">
                            <desc>Captures text to be used to generate a label for the element to which it's attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.</desc>
                            <datatype maxOccurs="1" minOccurs="1">
                                <rng:data type="string"/>
                            </datatype>
                            <remarks>
                                <p part="N">
                                    <att scheme="TEI">label</att>
                                    is used to provide a display label for an element's contents, for example in the form of a "tool tip" or as the "name" when the element's contents are treated as the "value" in a "name-value pair". Unlike
                                    <att scheme="TEI">n</att>
                                    ,
                                    <att scheme="TEI">label</att>
                                    may contain space characters.</p>
                                <p part="N">Don't confuse this attribute with the
                                    <gi scheme="MEI">label</gi>
                                    element, which records document content.</p>
                            </remarks>
                        </attDef>
                    </attList>
                </classSpec>
                <classSpec ident="att.linking" module="MEI.shared" type="atts" mode="add">
                    <desc>Attributes that specify element-to-element relationships.</desc>
                    <attList org="group">
                        <attDef ident="copyof" usage="opt">
                            <desc>Points to an element of which the current element is a copy.</desc>
                            <datatype maxOccurs="1" minOccurs="1">
                                <rng:ref name="data.URI" />
                            </datatype>
                            <constraintSpec ident="When_copyof_element_empty" scheme="schematron">
                                <constraint>
                                    <sch:rule context="mei:*[@copyof]">
                                        <sch:assert test="count(child::*[not(comment() or processing-instruction())]) = 0">An element with a copyof attribute can only have comment or processing instruction descendents.</sch:assert>
                                    </sch:rule>
                                </constraint>
                            </constraintSpec>
                            <constraintSpec ident="check_copyofTarget" scheme="schematron">
                                <constraint>
                                    <sch:rule context="@copyof">
                                        <sch:assert role="warning" test="not(normalize-space(.) eq '')">@copyof attribute should have content.</sch:assert>
                                        <sch:assert role="warning" test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id">The value in @copyof should correspond to the @xml:id attribute of an element.</sch:assert>
                                    </sch:rule>
                                </constraint>
                            </constraintSpec>
                        </attDef>
                        <attDef ident="corresp" usage="opt">
                            <desc>Used to point to other elements that correspond to this one in a generic fashion.</desc>
                            <datatype maxOccurs="unbounded" minOccurs="1">
                                <rng:ref name="data.URI" />
                            </datatype>
                            <constraintSpec ident="check_correspTarget" scheme="schematron">
                                <constraint>
                                    <sch:rule context="@corresp">
                                        <sch:assert role="warning" test="not(normalize-space(.) eq '')">@corresp attribute should have content.</sch:assert>
                                        <sch:assert role="warning" test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id">Each value in @corresp should correspond to the @xml:id attribute of an element.</sch:assert>
                                    </sch:rule>
                                </constraint>
                            </constraintSpec>
                        </attDef>
                        <attDef ident="follows" usage="opt">
                            <desc>points to one or more events in a user-defined collection that are known to be predecessors of the current element.</desc>
                            <datatype maxOccurs="unbounded" minOccurs="1">
                                <rng:ref name="data.URI" />
                            </datatype>
                            <constraintSpec ident="check_followsTarget" scheme="schematron">
                                <constraint>
                                    <sch:rule context="@follows">
                                        <sch:assert role="warning" test="not(normalize-space(.) eq '')">@follows attribute should have content.</sch:assert>
                                        <sch:assert role="warning" test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id">Each value in @follows must correspond to the @xml:id attribute of an element.</sch:assert>
                                    </sch:rule>
                                </constraint>
                            </constraintSpec>
                        </attDef>
                        <attDef ident="next" usage="opt">
                            <desc>Used to point to the next event(s) in a user-defined collection.</desc>
                            <datatype maxOccurs="unbounded" minOccurs="1">
                                <rng:ref name="data.URI" />
                            </datatype>
                            <constraintSpec ident="check_nextTarget" scheme="schematron">
                                <constraint>
                                    <sch:rule context="@next">
                                        <sch:assert role="warning" test="not(normalize-space(.) eq '')">@next attribute should have content.</sch:assert>
                                        <sch:assert role="warning" test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id">Each value in @next should correspond to the @xml:id attribute of an element.</sch:assert>
                                    </sch:rule>
                                </constraint>
                            </constraintSpec>
                        </attDef>
                        <attDef ident="precedes" usage="opt">
                            <desc>Points to one or more events in a user-defined collection that are known to be successors of the current element.</desc>
                            <datatype maxOccurs="unbounded" minOccurs="1">
                                <rng:ref name="data.URI" />
                            </datatype>
                            <constraintSpec ident="check_precedesTarget" scheme="schematron">
                                <constraint>
                                    <sch:rule context="@precedes">
                                        <sch:assert role="warning" test="not(normalize-space(.) eq '')">@precedes attribute should have content.</sch:assert>
                                        <sch:assert role="warning" test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id">Each value in @precedes must correspond to the @xml:id attribute of an element.</sch:assert>
                                    </sch:rule>
                                </constraint>
                            </constraintSpec>
                        </attDef>
                        <attDef ident="prev" usage="opt">
                            <desc>Points to the previous event(s) in a user-defined collection.</desc>
                            <datatype maxOccurs="unbounded" minOccurs="1">
                                <rng:ref name="data.URI" />
                            </datatype>
                            <constraintSpec ident="check_prevTarget" scheme="schematron">
                                <constraint>
                                    <sch:rule context="@prev">
                                        <sch:assert role="warning" test="not(normalize-space(.) eq '')">@prev attribute should have content.</sch:assert>
                                        <sch:assert role="warning" test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id">Each value in @prev should correspond to the @xml:id attribute of an element.</sch:assert>
                                    </sch:rule>
                                </constraint>
                            </constraintSpec>
                        </attDef>
                        <attDef ident="sameas" usage="opt">
                            <desc>Points to an element that is the same as the current element but is not a literal copy of the current element.</desc>
                            <datatype maxOccurs="unbounded" minOccurs="1">
                                <rng:ref name="data.URI" />
                            </datatype>
                            <constraintSpec ident="check_sameasTarget" scheme="schematron">
                                <constraint>
                                    <sch:rule context="@sameas">
                                        <sch:assert role="warning" test="not(normalize-space(.) eq '')">@sameas attribute should have content.</sch:assert>
                                        <sch:assert role="warning" test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id">Each value in @sameas should correspond to the @xml:id attribute of an element.</sch:assert>
                                    </sch:rule>
                                </constraint>
                            </constraintSpec>
                        </attDef>
                        <attDef ident="synch" usage="opt">
                            <desc>Points to elements that are synchronous with the current element.</desc>
                            <datatype maxOccurs="unbounded" minOccurs="1">
                                <rng:ref name="data.URI" />
                            </datatype>
                            <constraintSpec ident="check_synchTarget" scheme="schematron">
                                <constraint>
                                    <sch:rule context="@synch">
                                        <sch:assert role="warning" test="not(normalize-space(.) eq '')">@synch attribute should have content.</sch:assert>
                                        <sch:assert role="warning" test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id">Each value in @synch should correspond to the @xml:id attribute of an element.</sch:assert>
                                    </sch:rule>
                                </constraint>
                            </constraintSpec>
                        </attDef>
                    </attList>
                </classSpec>
                <classSpec ident="att.nNumberLike" module="MEI.shared" type="atts" mode="add">
                    <desc>Attributes used to supply a number-like designation for an element.</desc>
                    <attList org="group">
                        <attDef ident="n" usage="opt">
                            <desc>Provides a number-like designation that indicates an element's position in a sequence of similar elements. May not contain space characters.</desc>
                            <datatype maxOccurs="1" minOccurs="1">
                                <rng:ref name="data.WORD" />
                            </datatype>
                        </attDef>
                    </attList>
                </classSpec>
                <classSpec ident="att.responsibility" module="MEI.shared" type="atts" mode="add">
                    <desc>Attributes capturing information regarding responsibility for some aspect of the text's creation, transcription, editing, or encoding.</desc>
                    <attList org="group">
                        <attDef ident="resp" usage="opt">
                            <desc>Indicates the agent(s) responsible for some aspect of the text's transcription, editing, or encoding. Its value must point to one or more identifiers declared in the document header.</desc>
                            <datatype maxOccurs="unbounded" minOccurs="1">
                                <rng:ref name="data.URI" />
                            </datatype>
                            <constraintSpec ident="check_respTarget" scheme="schematron">
                                <constraint>
                                    <sch:rule context="@resp">
                                        <sch:assert role="warning" test="not(normalize-space(.) eq '')">@resp attribute should have content.</sch:assert>
                                        <sch:assert role="warning" test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*[ancestor::mei:meiHead]/@xml:id">The value in @resp should correspond to the @xml:id attribute of an element within the metadata header.</sch:assert>
                                    </sch:rule>
                                </constraint>
                            </constraintSpec>
                        </attDef>
                    </attList>
                </classSpec>
                <classSpec ident="att.typed" module="MEI.shared" type="atts" mode="add">
                    <desc>Attributes which can be used to classify features.</desc>
                    <classes>
                        <memberOf key="att.classed"/>
                    </classes>
                    <attList org="group">
                        <attDef ident="type" usage="opt">
                            <desc>Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.</desc>
                            <datatype maxOccurs="unbounded" minOccurs="1">
                                <rng:data type="NMTOKEN"/>
                            </datatype>
                        </attDef>
                    </attList>
                    <remarks>
                        <p part="N">When appropriate, values from an established typology should be used.</p>
                    </remarks>
                </classSpec>
                <classSpec ident="att.classed" module="MEI.shared" type="atts" mode="add">
                    <desc>Attributes which can be used to classify features.</desc>
                    <attList org="group">
                        <attDef ident="class" usage="opt">
                            <desc>Contains one or more URIs which denote classification terms that apply to the entity bearing this attribute.</desc>
                            <datatype maxOccurs="unbounded" minOccurs="1">
                                <rng:ref name="data.URI" />
                            </datatype>
                            <constraintSpec ident="check_classURI" scheme="schematron">
                                <constraint>
                                    <sch:rule context="@class">
                                        <sch:assert test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:category/@xml:id or matches($i, '^([a-z]+://|\.{1,2}/)')">The value in @class must either correspond to the @xml:id attribute of a category element or be an external URL.</sch:assert>
                                    </sch:rule>
                                </constraint>
                            </constraintSpec>
                        </attDef>
                    </attList>
                </classSpec>
                <classSpec ident="att.bibl" module="MEI.shared" type="atts" mode="add">
                    <desc>Bibliographic attributes.</desc>
                    <attList org="group">
                        <attDef ident="analog" usage="opt">
                            <desc>Contains a reference to a field or element in another descriptive encoding system to which this MEI element is comparable.</desc>
                            <datatype maxOccurs="1" minOccurs="1">
                                <rng:data type="string"/>
                            </datatype>
                        </attDef>
                    </attList>
                    <remarks>
                        <p part="N">Mapping elements from one system to another via
                            <att scheme="TEI">analog</att>
                            may help a repository harvest selected data from the MEI file to build a basic catalog record. The encoding system from which fields are taken must be specified. When possible, subfields as well as fields should be specified, e.g., subfields within MARC fields.</p>
                    </remarks>
                </classSpec>
                <classSpec ident="att.lang" module="MEI.shared" type="atts" mode="add">
                    <desc>Language attributes common to text elements.</desc>
                    <attList org="group">
                        <attDef ident="xml:lang" usage="opt">
                            <desc>Identifies the language of the element's content. The values for this attribute are language 'tags' as defined in BCP 47. All language tags that make use of private use sub-tags must be documented in a corresponding language element in the MEI header whose id attribute is the same as the language tag's value.</desc>
                            <datatype maxOccurs="1" minOccurs="1">
                                <rng:data type="language"/>
                            </datatype>
                        </attDef>
                        <attDef ident="translit" usage="opt">
                            <desc>Specifies the transliteration technique used.</desc>
                            <datatype maxOccurs="1" minOccurs="1">
                                <rng:data type="NMTOKEN"/>
                            </datatype>
                            <remarks>
                                <p part="N">There is no standard list of transliteration schemes.</p>
                            </remarks>
                        </attDef>
                    </attList>
                    <remarks>
                        <p part="N">BCP 47 is described at
                            <ref target="https://tools.ietf.org/html/bcp47">https://tools.ietf.org/html/bcp47</ref>
                            . The IANA Subtag Registry, from which BCP 47 language tags are constructed, may be found at
                            <ref target="www.iana.org/assignments/language-subtag-registry">www.iana.org/assignments/language-subtag-registry</ref>
                            . A tool for locating subtags and validating language tags is available at
                            <ref target="https://r12a.github.io/apps/subtags">https://r12a.github.io/apps/subtags</ref>
                            .</p>
                    </remarks>
                </classSpec>
                <classSpec ident="att.tempo.log" module="MEI.shared" type="atts" mode="add">
                    <desc>Logical domain attributes.</desc>
                    <classes>
                        <memberOf key="att.controlEvent"/>
                        <memberOf key="att.mmTempo"/>
                        <memberOf key="att.startId"/>
                    </classes>
                    <attList org="group">
                        <attDef ident="func" usage="opt">
                            <desc>Records the function of a tempo indication.</desc>
                            <valList type="closed">
                                <valItem ident="continuous">
                                    <desc>Marks a gradual change of tempo, such as "accel." or "rit."</desc>
                                </valItem>
                                <valItem ident="instantaneous">
                                    <desc>Represents a static tempo instruction, such as a textual term like "Adagio", a metronome marking like "♩=70", or a combination of text and metronome indication.</desc>
                                </valItem>
                                <valItem ident="metricmod">
                                    <desc>Captures a change in pulse rate (tempo) and/or pulse grouping (subdivision) in an "equation" of the form [tempo before change] = [tempo after change].</desc>
                                </valItem>
                                <valItem ident="precedente">
                                    <desc>Indicates a change in pulse rate (tempo) and/or pulse grouping (subdivision) in an "equation" of the form [tempo after change] = [tempo before change]. The term "precedente" often appears following the "equation" to distinguish this kind of historical usage from the modern metric modulation form.</desc>
                                </valItem>
                            </valList>
                        </attDef>
                    </attList>
                </classSpec>
                <classSpec ident="att.controlEvent" module="MEI.shared" type="atts" mode="add">
                    <desc>Attributes shared by events which rely on other events for their existence. For example, a slur/phrase marking must be drawn between or over a group of notes. The slur is therefore a control event.</desc>
                    <classes>
                        <memberOf key="att.alignment"/>
                        <memberOf key="att.layerIdent"/>
                        <memberOf key="att.partIdent"/>
                        <memberOf key="att.plist"/>
                        <memberOf key="att.staffIdent"/>
                        <memberOf key="att.targetEval"/>
                        <memberOf key="att.timestamp.logical"/>
                        <memberOf key="att.timestamp.gestural"/>
                    </classes>
                </classSpec>
                <classSpec ident="att.layerIdent" module="MEI.shared" type="atts" mode="add">
                    <desc>Attributes that identify the layer to which a feature applies.</desc>
                    <attList org="group">
                        <attDef ident="layer" usage="opt">
                            <desc>Identifies the layer to which a feature applies.</desc>
                            <datatype maxOccurs="unbounded" minOccurs="1">
                                <rng:data type="positiveInteger"/>
                            </datatype>
                        </attDef>
                    </attList>
                </classSpec>
                <classSpec ident="att.partIdent" module="MEI.shared" type="atts" mode="add">
                    <desc>Attributes for identifying the part in which the current feature appears.</desc>
                    <attList org="group">
                        <attDef ident="part" usage="opt">
                            <desc>Indicates the part in which the current feature should appear. Use '%all' when the feature should occur in every part.</desc>
                            <datatype maxOccurs="unbounded" minOccurs="1">
                                <rng:data type="token">
                                    <rng:param name="pattern">(%all|#[\i][\c]+)</rng:param>
                                </rng:data>
                            </datatype>
                            <constraintSpec ident="check_part_attr_all" scheme="schematron">
                                <constraint>
                                    <sch:rule context="@part[some $i in tokenize(., '\s+') satisfies (matches($i, '^%all$'))]">
                                        <sch:assert test="count(tokenize(., '\s+')) = 1">'%all' cannot be mixed with other values.</sch:assert>
                                    </sch:rule>
                                </constraint>
                            </constraintSpec>
                        </attDef>
                        <attDef ident="partstaff" usage="opt">
                            <desc>Signifies the part staff on which a notated feature occurs. Use '%all' when the feature should occur on every staff.</desc>
                            <datatype maxOccurs="unbounded" minOccurs="1">
                                <rng:data type="token">
                                    <rng:param name="pattern">(%all|\d+(-\d+)?)</rng:param>
                                </rng:data>
                            </datatype>
                            <constraintSpec ident="check_partstaff_attr_all" scheme="schematron">
                                <constraint>
                                    <sch:rule context="@partstaff[some $i in tokenize(., '\s+') satisfies (matches($i, '^%all$'))]">
                                        <sch:assert test="count(tokenize(., '\s+')) = 1">'%all' cannot be mixed with other values.</sch:assert>
                                    </sch:rule>
                                </constraint>
                            </constraintSpec>
                        </attDef>
                    </attList>
                </classSpec>
                <classSpec ident="att.plist" module="MEI.shared" type="atts" mode="add">
                    <desc>Attributes listing the active participants in a user-defined collection.</desc>
                    <attList org="group">
                        <attDef ident="plist" usage="opt">
                            <desc>When the target attribute is present, plist identifies the active participants; that is, those entities pointed "from", in a relationship with the specified target(s). When the target attribute is not present, it identifies participants in a mutual relationship.</desc>
                            <datatype maxOccurs="unbounded" minOccurs="1">
                                <rng:ref name="data.URI" />
                            </datatype>
                            <constraintSpec ident="check_plistTarget" scheme="schematron">
                                <constraint>
                                    <sch:rule context="@plist">
                                        <sch:assert role="warning" test="not(normalize-space(.) eq '')">@plist attribute should have content.</sch:assert>
                                        <sch:assert role="warning" test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id">Each value in @plist should correspond to the @xml:id attribute of an element.</sch:assert>
                                    </sch:rule>
                                </constraint>
                            </constraintSpec>
                        </attDef>
                    </attList>
                </classSpec>
                <classSpec ident="att.staffIdent" module="MEI.shared" type="atts" mode="add">
                    <desc>Attributes for identifying the staff associated with the current feature.</desc>
                    <attList org="group">
                        <attDef ident="staff" usage="rec">
                            <desc>Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.</desc>
                            <datatype maxOccurs="unbounded" minOccurs="1">
                                <rng:data type="positiveInteger"/>
                            </datatype>
                        </attDef>
                    </attList>
                </classSpec>
                <classSpec ident="att.targetEval" module="MEI.shared" type="atts" mode="add">
                    <desc>Attributes that deal with resolution of values in plist or target attributes.</desc>
                    <attList org="group">
                        <attDef ident="evaluate" usage="opt">
                            <desc>Specifies the intended meaning when a participant in a relationship is itself a pointer.</desc>
                            <valList type="closed">
                                <valItem ident="all">
                                    <desc>If an element pointed to is itself a pointer, then the target of that pointer will be taken, and so on, until an element is found which is not a pointer.</desc>
                                </valItem>
                                <valItem ident="one">
                                    <desc>If an element pointed to is itself a pointer, then its target (whether a pointer or not) is taken as the target of this pointer.</desc>
                                </valItem>
                                <valItem ident="none">
                                    <desc>No further evaluation of targets is carried out beyond that needed to find the element(s) specified in plist or target attribute.</desc>
                                </valItem>
                            </valList>
                            <remarks>
                                <p part="N">If no value is given, the application program is responsible for deciding (possibly on the basis of user input) how far to trace a chain of pointers.</p>
                            </remarks>
                        </attDef>
                    </attList>
                </classSpec>
                <classSpec ident="att.timestamp.logical" module="MEI.shared" type="atts" mode="add">
                    <desc>Attributes that record a time stamp in terms of musical time, i.e., beats[.fractional beat part].</desc>
                    <attList org="group">
                        <attDef ident="tstamp" usage="opt">
                            <desc>Encodes the onset time in terms of musical time, i.e., beats[.fractional beat part], as expressed in the written time signature.</desc>
                            <datatype maxOccurs="1" minOccurs="1">
                                <rng:ref name="data.BEAT" />
                            </datatype>
                        </attDef>
                    </attList>
                </classSpec>
                <classSpec ident="att.mmTempo" module="MEI.shared" type="atts" mode="add">
                    <desc>Attributes that record tempo in terms of beats per minute.</desc>
                    <attList org="group">
                        <attDef ident="mm" usage="opt">
                            <desc>Used to describe tempo in terms of beats (often the meter signature denominator) per minute, ala M.M. (Maezel's Metronome). Do not confuse this attribute with midi.bpm or midi.mspb. In MIDI, a beat is always defined as a quarter note, *not the numerator of the time signature or the metronomic indication*.</desc>
                            <datatype maxOccurs="1" minOccurs="1">
                                <rng:ref name="data.TEMPOVALUE" />
                            </datatype>
                        </attDef>
                        <attDef ident="mm.unit" usage="opt">
                            <desc>Captures the metronomic unit.</desc>
                            <datatype maxOccurs="1" minOccurs="1">
                                <rng:ref name="data.DURATION" />
                            </datatype>
                        </attDef>
                        <attDef ident="mm.dots" usage="opt">
                            <desc>Records the number of augmentation dots required by a dotted metronome unit.</desc>
                            <datatype maxOccurs="1" minOccurs="1">
                                <rng:ref name="data.AUGMENTDOT" />
                            </datatype>
                        </attDef>
                    </attList>
                </classSpec>
                <classSpec ident="att.startId" module="MEI.shared" type="atts" mode="add">
                    <desc>Attributes that identify a relative starting point.</desc>
                    <attList org="group">
                        <attDef ident="startid" usage="opt">
                            <desc>Holds a reference to the first element in a sequence of events to which the feature applies.</desc>
                            <datatype maxOccurs="1" minOccurs="1">
                                <rng:ref name="data.URI" />
                            </datatype>
                            <constraintSpec ident="check_startidTarget" scheme="schematron">
                                <constraint>
                                    <sch:rule context="@startid">
                                        <sch:assert role="warning" test="not(normalize-space(.) eq '')">@startid attribute should have content.</sch:assert>
                                        <sch:assert role="warning" test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id">The value in @startid should correspond to the @xml:id attribute of an element.</sch:assert>
                                    </sch:rule>
                                </constraint>
                            </constraintSpec>
                        </attDef>
                    </attList>
                </classSpec>
                <classSpec ident="att.placement" module="MEI.shared" type="atts" mode="add">
                    <desc>Attributes capturing placement information.</desc>
                    <attList org="group">
                        <attDef ident="place" usage="opt">
                            <desc>Captures the placement of the item with respect to the staff with which it is associated.</desc>
                            <datatype maxOccurs="1" minOccurs="1">
                                <rng:ref name="data.STAFFREL" />
                            </datatype>
                        </attDef>
                    </attList>
                </classSpec>
                <classSpec ident="att.metadataPointing" module="MEI.shared" type="atts" mode="add">
                    <desc>Provides attributes for elements which may be associated with particular contextual elements within the header.</desc>
                    <attList org="group">
                        <attDef ident="decls" usage="opt">
                            <desc>Identifies one or more metadata elements (other than classification terms) within the header, which are understood to apply to the element bearing this attribute and its content.</desc>
                            <datatype maxOccurs="unbounded" minOccurs="1">
                                <rng:ref name="data.URI" />
                            </datatype>
                            <constraintSpec ident="check_declsTarget" scheme="schematron">
                                <constraint>
                                    <sch:rule context="@decls">
                                        <sch:assert role="warning" test="not(normalize-space(.) eq '')">@decls attribute should have content.</sch:assert>
                                        <sch:assert role="warning" test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*[ancestor::mei:meiHead]/@xml:id">Each value in @decls should correspond to the @xml:id attribute of an element within the metadata header.</sch:assert>
                                        <sch:assert test="every $i in tokenize(., '\s+') satisfies not(substring($i,2)=//mei:term/@xml:id)">No value in @decls should correspond to the @xml:id attribute of a classification term. Use @class for this purpose.</sch:assert>
                                    </sch:rule>
                                </constraint>
                            </constraintSpec>
                        </attDef>
                    </attList>
                </classSpec>
                <classSpec ident="att.score.log" module="MEI.shared" type="atts" mode="add">
                    <desc>Logical domain attributes.</desc>
                </classSpec>
                <classSpec ident="att.color" module="MEI.shared" type="atts" mode="add">
                    <desc>Visual color attributes.</desc>
                    <attList org="group">
                        <attDef ident="color" usage="opt">
                            <desc>Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.</desc>
                            <datatype maxOccurs="1" minOccurs="1">
                                <rng:ref name="data.COLOR" />
                            </datatype>
                        </attDef>
                    </attList>
                </classSpec>
                <classSpec ident="att.sylText" module="MEI.shared" type="atts" mode="add">
                    <desc>Attributes that hold associated sung text syllables.</desc>
                    <attList org="group">
                        <attDef ident="syl" usage="opt">
                            <desc>Holds an associated sung text syllable.</desc>
                            <datatype maxOccurs="1" minOccurs="1">
                                <rng:data type="string"/>
                            </datatype>
                        </attDef>
                    </attList>
                </classSpec>
                
                <moduleRef key="MEI.header"
                include="editionStmt encodingDesc fileDesc meiHead notesStmt perfRes perfResList physDesc pubStmt revisionDesc seriesStmt source sourceDesc"/>
                <elementSpec ident="encodingDesc" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.header">
                    <desc>(encoding description) – Documents the relationship between an electronic file and the source or sources from which it was derived as well as applications used in the encoding/editing process.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.bibl"/>
                        <memberOf key="model.headerPart"/>
                    </classes>
                    <content>
                        <rng:zeroOrMore>
                            <rng:ref name="model.headLike" />
                        </rng:zeroOrMore>
                        <rng:optional>
                            <rng:ref name="appInfo" />
                        </rng:optional>
                        <rng:optional>
                            <rng:ref name="editorialDecl" />
                        </rng:optional>
                        <rng:optional>
                            <rng:ref name="projectDesc" />
                        </rng:optional>
                        <rng:optional>
                            <rng:ref name="samplingDecl" />
                        </rng:optional>
                        <rng:zeroOrMore>
                            <rng:ref name="domainsDecl" />
                        </rng:zeroOrMore>
                        <rng:optional>
                            <rng:ref name="tagsDecl" />
                        </rng:optional>
                        <rng:optional>
                            <rng:ref name="classDecls" />
                        </rng:optional>
                    </content>
                    <remarks>
                        <p part="N">This element is modelled on an element in the Text Encoding Initiative (TEI) standard.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="meiHead" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.header">
                    <desc>(MEI header) – Supplies the descriptive and declarative metadata prefixed to every MEI-conformant text.</desc>
                    <classes>
                        <memberOf key="att.basic"/>
                        <memberOf key="att.bibl"/>
                        <memberOf key="att.labelled"/>
                        <memberOf key="att.lang"/>
                        <memberOf key="att.meiVersion"/>
                        <memberOf key="att.responsibility"/>
                        <memberOf key="model.startLike.header"/>
                    </classes>
                    <content>
                        <rng:zeroOrMore>
                            <rng:ref name="altId" />
                        </rng:zeroOrMore>
                        <rng:ref name="fileDesc" />
                        <rng:optional>
                            <rng:ref name="encodingDesc" />
                        </rng:optional>
                        <rng:optional>
                            <rng:ref name="workList" />
                        </rng:optional>
                        <rng:optional>
                            <rng:ref name="manifestationList" />
                        </rng:optional>
                        <rng:zeroOrMore>
                            <rng:ref name="extMeta" />
                        </rng:zeroOrMore>
                        <rng:optional>
                            <rng:ref name="revisionDesc" />
                        </rng:optional>
                    </content>
                    <constraintSpec ident="check_meiHead_type" scheme="schematron">
                        <constraint>
                            <sch:rule context="mei:meiHead[@type eq 'music']">
                                <sch:assert test="ancestor::mei:mei">The meiHead type attribute can have the value 'music' only when the document element is "mei".</sch:assert>
                            </sch:rule>
                            <sch:rule context="mei:meiHead[@type eq 'corpus']">
                                <sch:assert test="ancestor::mei:meiCorpus">The meiHead type attribute can have the value 'corpus' only when the document element is "meiCorpus".</sch:assert>
                            </sch:rule>
                            <sch:rule context="mei:meiHead[@type eq 'independent']">
                                <sch:assert test="not(ancestor::mei:*)">The meiHead type attribute can have the value 'independent' only when the document element is "meiHead".</sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    <attList org="group">
                        <attDef ident="type" usage="opt">
                            <desc>Specifies the kind of document to which the header is attached, for example whether it is a corpus or individual text.</desc>
                            <valList type="closed">
                                <valItem ident="music">
                                    <desc>Header is attached to a music document.</desc>
                                </valItem>
                                <valItem ident="corpus">
                                    <desc>Header is attached to a corpus.</desc>
                                </valItem>
                                <valItem ident="independent">
                                    <desc>Header is independent; i.e., not attached to either a music or a corpus document.</desc>
                                </valItem>
                            </valList>
                        </attDef>
                    </attList>
                    <remarks>
                        <p part="N">In order to encourage uniformity in the provision of metadata across document types, this element is modelled on an element in the Text Encoding Initiative (TEI) standard. This information is often essential in a machine-readable environment. Five sub-elements must be encoded in the following order:
                            <gi scheme="MEI">altId</gi>
                            (optional),
                            <gi scheme="MEI">fileDesc</gi>
                            (required),
                            <gi scheme="MEI">encodingDesc</gi>
                            (optional),
                            <gi scheme="MEI">workList</gi>
                            (optional), and
                            <gi scheme="MEI">revisionDesc</gi>
                            (optional). These elements and their sub-elements provide: a unique identifier for the MEI file, bibliographic information about the MEI file and its sources, information about the encoding process, information about the creation of the work being encoded, and statements regarding significant revisions of the file. The
                            <att scheme="TEI">xml:lang</att>
                            attribute may be used to indicate the language in which the metadata content of the header is provided.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="fileDesc" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.header">
                    <desc>(file description) – Contains a full bibliographic description of the MEI file.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.bibl"/>
                    </classes>
                    <content>
                        <rng:ref name="titleStmt" />
                        <rng:optional>
                            <rng:ref name="editionStmt" />
                        </rng:optional>
                        <rng:optional>
                            <rng:ref name="extent" />
                        </rng:optional>
                        <rng:ref name="pubStmt" />
                        <rng:optional>
                            <rng:ref name="seriesStmt" />
                        </rng:optional>
                        <rng:optional>
                            <rng:ref name="notesStmt" />
                        </rng:optional>
                        <rng:optional>
                            <rng:ref name="sourceDesc" />
                        </rng:optional>
                    </content>
                    <remarks>
                        <p part="N">Extent in this context represents file size.</p>
                    </remarks>
                    <remarks>
                        <p part="N">This element is modelled on elements in the Text Encoding Initiative (TEI) and Encoded Archival Description (EAD) standards.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="sourceDesc" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.header">
                    <desc>(source description) – A container for the descriptions of the source(s) used in the creation of the electronic file.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                    </classes>
                    <content>
                        <rng:zeroOrMore>
                            <rng:ref name="model.headLike" />
                        </rng:zeroOrMore>
                        <rng:oneOrMore>
                            <rng:ref name="source" />
                        </rng:oneOrMore>
                    </content>
                    <remarks>
                        <p part="N">This element is recommended where the MEI file is a transcription of existing music, but is not required when the data is originally created in MEI form.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="source" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.header">
                    <desc>A bibliographic description of a source used in the creation of the electronic file.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.authorized"/>
                        <memberOf key="att.bibl"/>
                        <memberOf key="att.componentType"/>
                        <memberOf key="att.dataPointing"/>
                        <memberOf key="att.pointing"/>
                        <memberOf key="att.recordType"/>
                        <memberOf key="att.targetEval"/>
                    </classes>
                    <content>
                        <rng:zeroOrMore>
                            <rng:ref name="model.headLike" />
                        </rng:zeroOrMore>
                        <rng:zeroOrMore>
                            <rng:choice>
                                <rng:ref name="locus" />
                                <rng:ref name="locusGrp" />
                            </rng:choice>
                        </rng:zeroOrMore>
                        <rng:zeroOrMore>
                            <rng:choice>
                                <rng:ref name="model.biblLike" />
                            </rng:choice>
                        </rng:zeroOrMore>
                    </content>
                    <constraintSpec ident="check_source_target" scheme="schematron">
                        <constraint>
                            <sch:rule context="mei:source/@target">
                                <sch:assert role="warning" test="not(normalize-space(.) eq '')">@target attribute should have content.</sch:assert>
                                <sch:assert role="warning" test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*[local-name() eq 'source' or local-name() eq 'manifestation']/@xml:id or matches($i, '^([a-z]+://|\.{1,2}/)')">Each value in @target should correspond to the @xml:id attribute of a source or manifestation element or be an external URI.</sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    <remarks>
                        <p part="N">This element contains, or references via its
                            <att scheme="TEI">target</att>
                            attribute, a description of a source used in the creation of the electronic file. For description of a physical embodiment of an expression of a work use the
                            <gi scheme="MEI">manifestation</gi>
                            element.</p>
                        <p part="N">The
                            <att scheme="TEI">data</att>
                            attribute may be used to reference one or more musical features found in the content of this particular source.</p>
                    </remarks>
                    <remarks>
                        <p part="N">This element is modelled on elements in the Text Encoding Initiative (TEI) and Encoded Archival Description (EAD) standards.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="notesStmt" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.header">
                    <desc>(notes statement)– Collects any notes providing information about a text additional to that recorded in other parts of the bibliographic description.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.bibl"/>
                    </classes>
                    <content>
                        <rng:zeroOrMore>
                            <rng:ref name="model.headLike" />
                        </rng:zeroOrMore>
                        <rng:oneOrMore>
                            <rng:ref name="model.annotLike" />
                        </rng:oneOrMore>
                    </content>
                    <remarks>
                        <p part="N">This element is modelled on an element in the Text Encoding Initiative (TEI) standard.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="physDesc" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.header">
                    <desc>(physical description) – Container for information about the appearance, construction, or handling of physical materials, such as their dimension, quantity, color, style, and technique of creation.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.bibl"/>
                    </classes>
                    <content>
                        <rng:zeroOrMore>
                            <rng:ref name="model.headLike" />
                        </rng:zeroOrMore>
                        <rng:zeroOrMore>
                            <rng:ref name="model.pLike" />
                        </rng:zeroOrMore>
                        <rng:zeroOrMore>
                            <rng:ref name="model.physDescPart" />
                        </rng:zeroOrMore>
                    </content>
                    <remarks>
                        <p part="N">Dedicatory text and title page features may also be encoded here when they are not transcribed as part of the front or back matter; i.e., when they are considered to be meta-data rather than a transcription.</p>
                    </remarks>
                    <remarks>
                        <p part="N">This element is modelled on an element in the Encoded Archival Description (EAD) standard.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="editionStmt" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.header">
                    <desc>(edition statement) – Container for meta-data pertaining to a particular edition of the material being described.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.bibl"/>
                        <memberOf key="att.lang"/>
                    </classes>
                    <content>
                        <rng:zeroOrMore>
                            <rng:ref name="model.headLike" />
                        </rng:zeroOrMore>
                        <rng:oneOrMore>
                            <rng:ref name="model.editionLike" />
                            <rng:zeroOrMore>
                                <rng:choice>
                                    <rng:ref name="model.respLikePart" />
                                    <rng:ref name="respStmt" />
                                </rng:choice>
                            </rng:zeroOrMore>
                        </rng:oneOrMore>
                    </content>
                    <remarks>
                        <p part="N">This element is modelled on elements in the Text Encoding Initiative (TEI) and Encoded Archival Description (EAD) standards.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="pubStmt" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.header">
                    <desc>(publication statement) – Container for information regarding the publication or distribution of a bibliographic item, including the publisher's name and address, the date of publication, and other relevant details.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.bibl"/>
                    </classes>
                    <content>
                        <rng:zeroOrMore>
                            <rng:ref name="model.headLike" />
                        </rng:zeroOrMore>
                        <rng:choice>
                            <rng:optional>
                                <rng:ref name="unpub" />
                            </rng:optional>
                            <rng:zeroOrMore>
                                <rng:ref name="model.pubStmtPart" />
                            </rng:zeroOrMore>
                        </rng:choice>
                    </content>
                    <remarks>
                        <p part="N">When an item is unpublished, use only the
                            <gi scheme="MEI">unpub</gi>
                            sub-element.</p>
                    </remarks>
                    <remarks>
                        <p part="N">This element is modelled on an element in the Text Encoding Initiative (TEI) standard.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="seriesStmt" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.header">
                    <desc>(series statement) – Groups information about the series, if any, to which a publication belongs.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.bibl"/>
                    </classes>
                    <content>
                        <rng:zeroOrMore>
                            <rng:ref name="model.headLike" />
                        </rng:zeroOrMore>
                        <rng:oneOrMore>
                            <rng:ref name="model.titleLike" />
                        </rng:oneOrMore>
                        <rng:zeroOrMore>
                            <rng:choice>
                                <rng:ref name="model.respLikePart" />
                                <rng:ref name="respStmt" />
                            </rng:choice>
                        </rng:zeroOrMore>
                        <rng:zeroOrMore>
                            <rng:choice>
                                <rng:ref name="model.identifierLike" />
                                <rng:ref name="biblScope" />
                                <rng:ref name="contents" />
                                <rng:ref name="seriesStmt" />
                            </rng:choice>
                        </rng:zeroOrMore>
                    </content>
                    <remarks>
                        <p part="N">The
                            <gi scheme="MEI">title</gi>
                            sub-element records the series title, the
                            <gi scheme="MEI">respStmt</gi>
                            element records the person or group responsible for the series, and the
                            <gi scheme="MEI">identifier</gi>
                            element contains a series identifier. The
                            <gi scheme="MEI">contents</gi>
                            element should be used when it is necessary to enumerate the content of the series, but not describe each component. The
                            <gi scheme="MEI">seriesStmt</gi>
                            element is provided within seriesStmt for the description of a sub-series.</p>
                    </remarks>
                    <remarks>
                        <p part="N">This element is modelled on an element in the Text Encoding Initiative (TEI) standard.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="revisionDesc" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.header">
                    <desc>(revision description) – Container for information about alterations that have been made to an MEI file.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.bibl"/>
                    </classes>
                    <content>
                        <rng:zeroOrMore>
                            <rng:ref name="model.headLike" />
                        </rng:zeroOrMore>
                        <rng:oneOrMore>
                            <rng:ref name="change" />
                        </rng:oneOrMore>
                    </content>
                    <remarks>
                        <p part="N">It is recommended that changes be recorded in reverse chronological order, with the most recent alteration first.</p>
                    </remarks>
                    <remarks>
                        <p part="N">This element is modelled on an element in the Text Encoding Initiative (TEI) standard.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="perfResList" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.header">
                    <desc>Several instrumental or vocal resources treated as a group.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.authorized"/>
                        <memberOf key="att.bibl"/>
                        <memberOf key="att.edit"/>
                        <memberOf key="att.lang"/>
                    </classes>
                    <content>
                        <rng:zeroOrMore>
                            <rng:ref name="model.headLike" />
                        </rng:zeroOrMore>
                        <rng:zeroOrMore>
                            <rng:choice>
                                <rng:ref name="annot" />
                                <rng:ref name="perfRes" />
                                <rng:ref name="perfResList" />
                            </rng:choice>
                        </rng:zeroOrMore>
                    </content>
                    <attList org="group">
                        <attDef ident="count" usage="opt">
                            <desc>Indicates the number of performers.</desc>
                            <datatype maxOccurs="1" minOccurs="1">
                                <rng:data type="positiveInteger"/>
                            </datatype>
                        </attDef>
                    </attList>
                    <remarks>
                        <p part="N">The function of instrumentalists or vocalists is represented by the choice of
                            <gi scheme="MEI">perfRes</gi>
                            and
                            <gi scheme="MEI">perfResList</gi>
                            child elements. Arrangements are coded for the medium of the work being described, not for the original medium.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="perfRes" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.header">
                    <desc>(performance resource) – Name of an instrument on which a performer plays, a performer's voice range, or a standard performing ensemble designation.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.authorized"/>
                        <memberOf key="att.bibl"/>
                        <memberOf key="att.edit"/>
                        <memberOf key="att.lang"/>
                    </classes>
                    <content>
                        <rng:zeroOrMore>
                            <rng:choice>
                                <rng:text/>
                                <rng:ref name="model.textPhraseLike.limited" />
                                <rng:ref name="perfRes" />
                            </rng:choice>
                        </rng:zeroOrMore>
                    </content>
                    <attList org="group">
                        <attDef ident="count" usage="opt">
                            <desc>Indicates the number of performers.</desc>
                            <datatype maxOccurs="1" minOccurs="1">
                                <rng:data type="positiveInteger"/>
                            </datatype>
                        </attDef>
                        <attDef ident="solo" usage="opt">
                            <desc>Marks this instrument or vocal part as a soloist. Do not use this attribute for a solo instrument which is not accompanied.</desc>
                            <datatype maxOccurs="1" minOccurs="1">
                                <rng:ref name="data.BOOLEAN" />
                            </datatype>
                        </attDef>
                    </attList>
                </elementSpec>
                
                <moduleRef key="MEI.cmn"
                include="arpeg bracketSpan fermata measure octave"/>
                <elementSpec ident="measure" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.cmn">
                    <desc>Unit of musical time consisting of a fixed number of note values of a given type, as determined by the prevailing meter, and delimited in musical notation by bar lines.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.facsimile"/>
                        <memberOf key="att.metadataPointing"/>
                        <memberOf key="att.pointing"/>
                        <memberOf key="att.measure.anl"/>
                        <memberOf key="att.measure.ges"/>
                        <memberOf key="att.measure.log"/>
                        <memberOf key="att.measure.vis"/>
                        <memberOf key="att.targetEval"/>
                        <memberOf key="model.measureLike"/>
                    </classes>
                    <content>
                        <rng:optional>
                            <rng:ref name="mNum" />
                        </rng:optional>
                        <rng:zeroOrMore>
                            <rng:choice>
                                <rng:ref name="model.annotLike" />
                                <rng:ref name="model.appLike" />
                                <rng:ref name="model.editLike" />
                                <rng:ref name="model.graphicPrimitiveLike" />
                                <rng:ref name="model.measurePart" />
                                <rng:ref name="model.milestoneLike.music" />
                                <rng:ref name="model.relationLike" />
                                <rng:ref name="model.staffDefLike" />
                                <rng:ref name="model.transcriptionLike" />
                            </rng:choice>
                        </rng:zeroOrMore>
                    </content>
                    <remarks>
                        <p part="N">In MEI, the
                            <gi scheme="MEI">measure</gi>
                            element is a grouping mechanism for events and control events. Pointing attributes make it possible to connect this element to other internal or external entities, such as media objects or annotations. The
                            <att scheme="TEI">width</att>
                            attribute may be used to capture the width of the measure for interchange with music printing systems that utilize this information for printing.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="octave" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.cmn">
                    <desc>An indication that a passage should be performed one or more octaves above or below its written pitch.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.facsimile"/>
                        <memberOf key="att.octave.log"/>
                        <memberOf key="att.octave.vis"/>
                        <memberOf key="att.octave.ges"/>
                        <memberOf key="att.octave.anl"/>
                        <memberOf key="model.controlEventLike.cmn"/>
                    </classes>
                    <content>
                        <rng:zeroOrMore>
                            <rng:choice>
                                <rng:text/>
                                <rng:ref name="model.textPhraseLike.limited" />
                            </rng:choice>
                        </rng:zeroOrMore>
                    </content>
                    <constraintSpec ident="octave_start-_and_end-type_attributes_required" scheme="schematron">
                        <constraint>
                            <sch:rule context="mei:octave">
                                <sch:assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one of the attributes: startid, tstamp, tstamp.ges or tstamp.real.</sch:assert>
                                <sch:assert test="@dur or @dur.ges or @endid or @tstamp2">Must have one of the attributes: dur, dur.ges, endid, or tstamp2.</sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    <remarks>
                        <p part="N">The
                            <att scheme="TEI">dis</att>
                            and
                            <att scheme="TEI">dis.place</att>
                            attributes record the amount and direction of displacement, respectively. The
                            <att scheme="TEI">lform</att>
                            and
                            <att scheme="TEI">lwidth</att>
                            attributes capture the appearance of the continuation line associated with the octave displacement. The starting point of the octave displacement may be indicated by either a
                            <att scheme="TEI">startid</att>
                            ,
                            <att scheme="TEI">tstamp</att>
                            ,
                            <att scheme="TEI">tstamp.ges</att>
                            , or
                            <att scheme="TEI">tstamp.real</att>
                            attribute, while the ending point may be recorded by either a
                            <att scheme="TEI">dur</att>
                            ,
                            <att scheme="TEI">dur.ges</att>
                            ,
                            <att scheme="TEI">endid</att>
                            , or
                            <att scheme="TEI">tstamp2</att>
                            attribute. It is a semantic error not to specify one starting and one ending type of attribute. Also, note that the
                            <att scheme="TEI">dur</att>
                            attribute is not required because the octave displacement can be visually instantaneous.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="arpeg" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.cmn">
                    <desc>(arpeggiation) – Indicates that the notes of a chord are to be performed successively rather than simultaneously, usually from lowest to highest. Sometimes called a "roll".</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.facsimile"/>
                        <memberOf key="att.arpeg.log"/>
                        <memberOf key="att.arpeg.vis"/>
                        <memberOf key="att.arpeg.ges"/>
                        <memberOf key="att.arpeg.anl"/>
                        <memberOf key="model.controlEventLike.cmn"/>
                    </classes>
                    <content>
                        <rng:empty/>
                    </content>
                    <remarks>
                        <p part="N">The modern arpeggiation symbol is a vertical wavy line preceding the chord. When the notes of the chord are to be performed from highest to lowest, an arrowhead may be added to the lower end of the line. Even though it is redundant, an arrowhead is sometimes added to the upper end of the line for the sake of consistency or when the direction of successive arpeggios alternates. In music for keyboard instruments, sometimes a distinction is made between a single arpeggio in which both hands play successively and simultaneous arpeggios in two hands. In the case of the former, multiple values may be required in the
                            <att scheme="TEI">staff</att>
                            and
                            <att scheme="TEI">layer</att>
                            attributes. Arpeggios that do not cross staves, but still involve more than one layer require multiple values for the
                            <att scheme="TEI">layer</att>
                            attribute.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="bracketSpan" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.cmn">
                    <desc>Marks a sequence of notational events grouped by a bracket.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.bracketSpan.log"/>
                        <memberOf key="att.bracketSpan.vis"/>
                        <memberOf key="att.bracketSpan.ges"/>
                        <memberOf key="att.bracketSpan.anl"/>
                        <memberOf key="att.facsimile"/>
                        <memberOf key="model.controlEventLike.cmn"/>
                    </classes>
                    <content>
                        <rng:zeroOrMore>
                            <rng:choice>
                                <rng:text/>
                                <rng:ref name="model.textPhraseLike.limited" />
                            </rng:choice>
                        </rng:zeroOrMore>
                    </content>
                    <constraintSpec ident="bracketSpan_start-_and_end-type_attributes_required" scheme="schematron">
                        <constraint>
                            <sch:rule context="mei:bracketSpan">
                                <sch:assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one of the attributes: startid, tstamp, tstamp.ges or tstamp.real.</sch:assert>
                                <sch:assert test="@dur or @dur.ges or @endid or @tstamp2">Must have one of the attributes: dur, dur.ges, endid, or tstamp2.</sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    <attList org="group">
                        <attDef ident="func" usage="req">
                            <desc>Describes the function of the bracketed event sequence.</desc>
                            <datatype maxOccurs="1" minOccurs="1">
                                <rng:data type="NMTOKENS"/>
                            </datatype>
                            <valList type="semi">
                                <valItem ident="coloration">
                                    <desc>Represents coloration in the mensural notation source material.</desc>
                                </valItem>
                                <valItem ident="cross-rhythm">
                                    <desc>Marks a sequence which does not match the current meter.</desc>
                                </valItem>
                                <valItem ident="ligature">
                                    <desc>Represents a ligature in the mensural notation source material.</desc>
                                </valItem>
                            </valList>
                        </attDef>
                    </attList>
                    <remarks>
                        <p part="N">Text that interrupts the bracket used to mark the event group may be captured as the content of
                            <gi scheme="MEI">bracketSpan</gi>
                            . The starting point of the group/bracket may be indicated by either a
                            <att scheme="TEI">startid</att>
                            ,
                            <att scheme="TEI">tstamp</att>
                            ,
                            <att scheme="TEI">tstamp.ges</att>
                            , or
                            <att scheme="TEI">tstamp.real</att>
                            attribute, while the ending point may be recorded by either a
                            <att scheme="TEI">dur</att>
                            ,
                            <att scheme="TEI">dur.ges</att>
                            ,
                            <att scheme="TEI">endid</att>
                            , or
                            <att scheme="TEI">tstamp2</att>
                            attribute. It is a semantic error not to specify one starting and one ending type of attribute.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="fermata" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.cmn">
                    <desc>An indication placed over a note or rest to indicate that it should be held longer than its written value. May also occur over a bar line to indicate the end of a phrase or section. Sometimes called a 'hold' or 'pause'.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.facsimile"/>
                        <memberOf key="att.fermata.log"/>
                        <memberOf key="att.fermata.vis"/>
                        <memberOf key="att.fermata.ges"/>
                        <memberOf key="att.fermata.anl"/>
                        <memberOf key="model.controlEventLike.cmn"/>
                    </classes>
                    <content>
                        <rng:empty/>
                    </content>
                    <constraintSpec ident="fermata_start-type_attributes_required" scheme="schematron">
                        <constraint>
                            <sch:rule context="mei:fermata">
                                <sch:assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one of the attributes: startid, tstamp, tstamp.ges or tstamp.real.</sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    <remarks>
                        <p part="N">The
                            <att scheme="TEI">shape</att>
                            attribute may be used to record whether the fermata is curved, square, or triangular, while
                            <att scheme="TEI">form</att>
                            may be used to capture whether the fermata is "upright", i.e., has the curve or bracket above the dot, or inverted, i.e., has the curve or bracket below the dot. Other visual forms of a fermata may be indicated via the
                            <att scheme="TEI">altsym</att>
                            attribute. The starting point of the fermata may be indicated by either a
                            <att scheme="TEI">startid</att>
                            ,
                            <att scheme="TEI">tstamp</att>
                            ,
                            <att scheme="TEI">tstamp.ges</att>
                            , or
                            <att scheme="TEI">tstamp.real</att>
                            attribute. It is a semantic error not to specify a starting point attribute.</p>
                    </remarks>
                </elementSpec>
                
                <moduleRef key="MEI.mensural"
                include="ligature mensur proport"/>
                <elementSpec ident="ligature" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.mensural">
                    <desc>A mensural notation symbol that combines two or more notes into a single sign.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.facsimile"/>
                        <memberOf key="att.ligature.log"/>
                        <memberOf key="att.ligature.vis"/>
                        <memberOf key="att.ligature.ges"/>
                        <memberOf key="att.ligature.anl"/>
                        <memberOf key="model.eventLike.mensural"/>
                    </classes>
                    <content>
                        <rng:zeroOrMore>
                            <rng:choice>
                                <rng:ref name="model.appLike" />
                                <rng:ref name="model.editLike" />
                                <rng:ref name="model.eventLike" />
                                <rng:ref name="model.eventLike.mensural" />
                                <rng:ref name="model.eventLike.neumes" />
                                <rng:ref name="model.transcriptionLike" />
                            </rng:choice>
                        </rng:zeroOrMore>
                    </content>
                    <remarks>
                        <p part="N">The rhythmic meaning of the components of a ligature is typically contextual, not absolute; therefore, an interpretative duration may be encoded on each of the components using either the
                            <att scheme="TEI">dur.ges</att>
                            attribute or the
                            <att scheme="TEI">num</att>
                            and
                            <att scheme="TEI">numbase</att>
                            attribute pair. The
                            <gi scheme="MEI">ligature</gi>
                            element should
                            <hi rend="bold">not</hi>
                            be used for brackets in modern notation that indicate notes that were part of a ligature in the original source.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="mensur" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.mensural">
                    <desc>(mensuration) – Collects information about the metrical relationship between a note value and the next smaller value; that is, either triple or duple.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.facsimile"/>
                        <memberOf key="att.mensur.log"/>
                        <memberOf key="att.mensur.vis"/>
                        <memberOf key="att.mensur.ges"/>
                        <memberOf key="att.mensur.anl"/>
                        <memberOf key="model.eventLike.mensural"/>
                        <memberOf key="model.staffDefPart.mensural"/>
                    </classes>
                    <content>
                        <rng:empty/>
                    </content>
                    <remarks>
                        <p part="N">The
                            <gi scheme="MEI">mensur</gi>
                            element is provided for the encoding of mensural notation. The
                            <att scheme="TEI">slash</att>
                            attribute indicates the number lines added to the mensuration sign. For example, one slash is added for what we now call 'alla breve'.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="proport" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.mensural">
                    <desc>(proportion) – Description of note duration as arithmetic ratio.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.facsimile"/>
                        <memberOf key="att.proport.log"/>
                        <memberOf key="att.proport.vis"/>
                        <memberOf key="att.proport.ges"/>
                        <memberOf key="att.proport.anl"/>
                        <memberOf key="model.eventLike.mensural"/>
                        <memberOf key="model.staffDefPart.mensural"/>
                    </classes>
                    <content>
                        <rng:empty/>
                    </content>
                    <remarks>
                        <p part="N">The proport element is provided for the encoding of mensural notation. It allows the description of note durations as arithmetic ratios. While mensuration refers to the normal relationships between note durations, proportion affects the relations of the note durations to the tactus.</p>
                    </remarks>
                </elementSpec>
                <classSpec ident="att.note.ges.mensural" module="MEI.mensural" type="atts" mode="add">
                    <desc>Gestural domain attributes.</desc>
                    <classes>
                        <memberOf key="att.duration.ratio"/>
                    </classes>
                </classSpec>
                <classSpec ident="att.note.log.mensural" module="MEI.mensural" type="atts" mode="add">
                    <desc>Logical domain attributes in the Mensural repertoire.</desc>
                </classSpec>
                <classSpec ident="att.mensural.shared" module="MEI.mensural" type="atts" mode="add">
                    <desc>Shared attributes in the mensural repertoire.</desc>
                    <attList org="group">
                        <attDef ident="modusmaior" usage="opt">
                            <desc>Describes the maxima-long relationship.</desc>
                            <datatype maxOccurs="1" minOccurs="1">
                                <rng:ref name="data.MODUSMAIOR" />
                            </datatype>
                        </attDef>
                        <attDef ident="modusminor" usage="opt">
                            <desc>Describes the long-breve relationship.</desc>
                            <datatype maxOccurs="1" minOccurs="1">
                                <rng:ref name="data.MODUSMINOR" />
                            </datatype>
                        </attDef>
                        <attDef ident="prolatio" usage="opt">
                            <desc>Describes the semibreve-minim relationship.</desc>
                            <datatype maxOccurs="1" minOccurs="1">
                                <rng:ref name="data.PROLATIO" />
                            </datatype>
                        </attDef>
                        <attDef ident="tempus" usage="opt">
                            <desc>Describes the breve-semibreve relationship.</desc>
                            <datatype maxOccurs="1" minOccurs="1">
                                <rng:ref name="data.TEMPUS" />
                            </datatype>
                        </attDef>
                    </attList>
                </classSpec>
                
                <moduleRef key="MEI.neumes"
                include="episma liquescent nc ncGrp neume oriscus quilisma signifLet"/>
                <elementSpec ident="liquescent" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.neumes">
                    <desc>Liquescent.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.facsimile"/>
                        <memberOf key="att.liquescent.anl"/>
                        <memberOf key="att.liquescent.ges"/>
                        <memberOf key="att.liquescent.log"/>
                        <memberOf key="att.liquescent.vis"/>
                        <memberOf key="model.neumeComponentModifierLike"/>
                    </classes>
                </elementSpec>
                <elementSpec ident="neume" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.neumes">
                    <desc>Sign representing one or more musical pitches.</desc>
                    <classes>
                        <memberOf key="att.basic"/>
                        <memberOf key="att.classed"/>
                        <memberOf key="att.facsimile"/>
                        <memberOf key="att.labelled"/>
                        <memberOf key="att.linking"/>
                        <memberOf key="att.nNumberLike"/>
                        <memberOf key="att.responsibility"/>
                        <memberOf key="att.neume.anl"/>
                        <memberOf key="att.neume.ges"/>
                        <memberOf key="att.neume.log"/>
                        <memberOf key="att.neume.vis"/>
                        <memberOf key="model.eventLike.neumes"/>
                    </classes>
                    <content>
                        <rng:zeroOrMore>
                            <rng:choice>
                                <rng:ref name="model.appLike" />
                                <rng:ref name="model.editLike" />
                                <rng:ref name="model.neumeModifierLike" />
                                <rng:ref name="model.neumePart" />
                                <rng:ref name="model.transcriptionLike" />
                            </rng:choice>
                        </rng:zeroOrMore>
                    </content>
                    <attList org="group">
                        <attDef ident="type" usage="opt">
                            <desc>Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.</desc>
                            <datatype maxOccurs="unbounded" minOccurs="1">
                                <rng:data type="NMTOKEN"/>
                            </datatype>
                            <valList type="semi">
                                <valItem ident="apostropha"/>
                                <valItem ident="bistropha"/>
                                <valItem ident="climacus"/>
                                <valItem ident="clivis"/>
                                <valItem ident="oriscus"/>
                                <valItem ident="pes"/>
                                <valItem ident="pessubpunctis"/>
                                <valItem ident="porrectus"/>
                                <valItem ident="porrectusflexus"/>
                                <valItem ident="pressusmaior"/>
                                <valItem ident="pressusmaior"/>
                                <valItem ident="pressusminor"/>
                                <valItem ident="pressusminor"/>
                                <valItem ident="punctum"/>
                                <valItem ident="quilisma"/>
                                <valItem ident="scandicus"/>
                                <valItem ident="strophicus"/>
                                <valItem ident="torculus"/>
                                <valItem ident="torculusresupinus"/>
                                <valItem ident="tristropha"/>
                                <valItem ident="virga"/>
                                <valItem ident="virgastrata"/>
                            </valList>
                        </attDef>
                    </attList>
                </elementSpec>
                <elementSpec ident="ncGrp" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.neumes">
                    <desc>Collection of one or more neume components.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.facsimile"/>
                        <memberOf key="att.ncGrp.anl"/>
                        <memberOf key="att.ncGrp.ges"/>
                        <memberOf key="att.ncGrp.log"/>
                        <memberOf key="att.ncGrp.vis"/>
                        <memberOf key="model.neumePart"/>
                    </classes>
                    <content>
                        <rng:zeroOrMore>
                            <rng:choice>
                                <rng:ref name="model.appLike" />
                                <rng:ref name="model.editLike" />
                                <rng:ref name="model.neumeModifierLike" />
                                <rng:ref name="model.transcriptionLike" />
                                <rng:ref name="nc" />
                                <rng:ref name="ncGrp" />
                            </rng:choice>
                        </rng:zeroOrMore>
                    </content>
                </elementSpec>
                <elementSpec ident="nc" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.neumes">
                    <desc>Sign representing a single pitched event, although the exact pitch may not be known.</desc>
                    <classes>
                        <memberOf key="att.basic"/>
                        <memberOf key="att.classed"/>
                        <memberOf key="att.facsimile"/>
                        <memberOf key="att.labelled"/>
                        <memberOf key="att.linking"/>
                        <memberOf key="att.nNumberLike"/>
                        <memberOf key="att.responsibility"/>
                        <memberOf key="att.nc.anl"/>
                        <memberOf key="att.nc.ges"/>
                        <memberOf key="att.nc.log"/>
                        <memberOf key="att.nc.vis"/>
                        <memberOf key="model.neumePart"/>
                    </classes>
                    <content>
                        <rng:zeroOrMore>
                            <rng:choice>
                                <rng:ref name="model.appLike" />
                                <rng:ref name="model.editLike" />
                                <rng:ref name="model.neumeComponentModifierLike" />
                                <rng:ref name="model.neumeModifierLike" />
                                <rng:ref name="model.transcriptionLike" />
                            </rng:choice>
                        </rng:zeroOrMore>
                    </content>
                    <attList org="group">
                        <attDef ident="type" usage="opt">
                            <desc>Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.</desc>
                            <datatype maxOccurs="unbounded" minOccurs="1">
                                <rng:data type="NMTOKEN"/>
                            </datatype>
                            <valList type="semi">
                                <valItem ident="apostropha"/>
                                <valItem ident="bistropha"/>
                                <valItem ident="climacus"/>
                                <valItem ident="clivis"/>
                                <valItem ident="oriscus"/>
                                <valItem ident="pes"/>
                                <valItem ident="pessubpunctis"/>
                                <valItem ident="porrectus"/>
                                <valItem ident="porrectusflexus"/>
                                <valItem ident="pressusmaior"/>
                                <valItem ident="pressusmaior"/>
                                <valItem ident="pressusminor"/>
                                <valItem ident="pressusminor"/>
                                <valItem ident="punctum"/>
                                <valItem ident="quilisma"/>
                                <valItem ident="scandicus"/>
                                <valItem ident="strophicus"/>
                                <valItem ident="torculus"/>
                                <valItem ident="torculusresupinus"/>
                                <valItem ident="tristropha"/>
                                <valItem ident="virga"/>
                                <valItem ident="virgastrata"/>
                            </valList>
                        </attDef>
                    </attList>
                </elementSpec>
                <elementSpec ident="episema" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.neumes">
                    <desc>Episema.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.facsimile"/>
                        <memberOf key="att.episema.anl"/>
                        <memberOf key="att.episema.ges"/>
                        <memberOf key="att.episema.log"/>
                        <memberOf key="att.episema.vis"/>
                        <memberOf key="model.neumeModifierLike"/>
                    </classes>
                </elementSpec>
                <elementSpec ident="oriscus" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.neumes">
                    <desc>Oriscus.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.facsimile"/>
                        <memberOf key="att.oriscus.anl"/>
                        <memberOf key="att.oriscus.ges"/>
                        <memberOf key="att.oriscus.log"/>
                        <memberOf key="att.oriscus.vis"/>
                        <memberOf key="model.neumeComponentModifierLike"/>
                    </classes>
                </elementSpec>
                <elementSpec ident="quilisma" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.neumes">
                    <desc>Quilisma.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.facsimile"/>
                        <memberOf key="att.quilisma.anl"/>
                        <memberOf key="att.quilisma.ges"/>
                        <memberOf key="att.quilisma.log"/>
                        <memberOf key="att.quilisma.vis"/>
                        <memberOf key="model.neumeComponentModifierLike"/>
                    </classes>
                </elementSpec>
                <elementSpec ident="signifLet" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.neumes">
                    <desc>Significantive letter(s).</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.facsimile"/>
                        <memberOf key="att.signifLet.anl"/>
                        <memberOf key="att.signifLet.ges"/>
                        <memberOf key="att.signifLet.log"/>
                        <memberOf key="att.signifLet.vis"/>
                        <memberOf key="model.neumeModifierLike"/>
                    </classes>
                    <content>
                        <rng:zeroOrMore>
                            <rng:choice>
                                <rng:text/>
                                <rng:ref name="model.textPhraseLike.limited" />
                                <rng:ref name="model.graphicPrimitiveLike" />
                                <rng:ref name="model.editLike" />
                                <rng:ref name="model.transcriptionLike" />
                            </rng:choice>
                        </rng:zeroOrMore>
                    </content>
                </elementSpec>
                <elementSpec ident="strophicus" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.neumes">
                    <desc>Strophicus.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.facsimile"/>
                        <memberOf key="att.strophicus.anl"/>
                        <memberOf key="att.strophicus.ges"/>
                        <memberOf key="att.strophicus.log"/>
                        <memberOf key="att.strophicus.vis"/>
                        <memberOf key="model.neumeComponentModifierLike"/>
                    </classes>
                </elementSpec>
                <classSpec ident="att.neume.log" module="MEI.neumes" type="atts" mode="add">
                    <desc>Logical domain attributes.</desc>
                    <classes>
                        <memberOf key="att.alignment"/>
                        <memberOf key="att.layerIdent"/>
                        <memberOf key="att.staffIdent"/>
                        <memberOf key="att.sylText"/>
                    </classes>
                </classSpec>
                
                <moduleRef key="MEI.analysis"/>
                
                <moduleRef key="MEI.msDesc"
                include="catchwords decoDesc decoNote heraldry locus locusGrp secFolio signatures stamp"/>
                <elementSpec ident="decoDesc" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.msDesc">
                    <desc>(decoration description) – Contains a description of the decoration of an item.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.bibl"/>
                        <memberOf key="att.lang"/>
                        <memberOf key="model.physDescPart"/>
                    </classes>
                    <content>
                        <rng:choice>
                            <rng:group>
                                <rng:zeroOrMore>
                                    <rng:ref name="head" />
                                </rng:zeroOrMore>
                                <rng:zeroOrMore>
                                    <rng:choice>
                                        <rng:ref name="condition" />
                                        <rng:ref name="decoNote" />
                                        <rng:ref name="p" />
                                    </rng:choice>
                                </rng:zeroOrMore>
                            </rng:group>
                            <rng:zeroOrMore>
                                <rng:choice>
                                    <rng:text/>
                                    <rng:ref name="model.textPhraseLike.limited" />
                                </rng:choice>
                            </rng:zeroOrMore>
                        </rng:choice>
                    </content>
                    <remarks>
                        <p part="N">This element is modelled on an element in the Text Encoding Initiative (TEI) standard.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="catchwords" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.msDesc">
                    <desc>Describes the system used to ensure correct ordering of the quires making up an item, typically by means of annotations at the foot of the page.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.bibl"/>
                        <memberOf key="att.lang"/>
                        <memberOf key="model.msInline"/>
                        <memberOf key="model.physDescPart"/>
                    </classes>
                    <content>
                        <rng:ref name="macro.struc-unstrucContent" />
                    </content>
                    <remarks>
                        <p part="N">This element is modelled on an element in the Text Encoding Initiative (TEI) standard.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="decoNote" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.msDesc">
                    <desc>(decoration note) – Contains a description of one or more decorative features of an item.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.bibl"/>
                        <memberOf key="att.lang"/>
                    </classes>
                    <content>
                        <rng:choice>
                            <rng:group>
                                <rng:zeroOrMore>
                                    <rng:ref name="head" />
                                </rng:zeroOrMore>
                                <rng:zeroOrMore>
                                    <rng:choice>
                                        <rng:ref name="condition" />
                                        <rng:ref name="decoNote" />
                                        <rng:ref name="p" />
                                    </rng:choice>
                                </rng:zeroOrMore>
                            </rng:group>
                            <rng:zeroOrMore>
                                <rng:choice>
                                    <rng:text/>
                                    <rng:ref name="model.textPhraseLike.limited" />
                                </rng:choice>
                            </rng:zeroOrMore>
                        </rng:choice>
                    </content>
                    <remarks>
                        <p part="N">This element is modelled on an element in the Text Encoding Initiative (TEI) standard.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="heraldry" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.msDesc">
                    <desc>Contains a heraldic formula or phrase, typically found as part of a blazon, coat of arms, etc.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.bibl"/>
                        <memberOf key="att.facsimile"/>
                        <memberOf key="att.lang"/>
                        <memberOf key="model.msInline"/>
                        <memberOf key="model.physDescPart"/>
                    </classes>
                    <content>
                        <rng:ref name="macro.struc-unstrucContent" />
                    </content>
                    <remarks>
                        <p part="N">This element is modelled on an element in the Text Encoding Initiative (TEI) standard.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="locus" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.msDesc">
                    <desc>Defines a location within a manuscript or manuscript component, usually as a (possibly discontinuous) sequence of folio references.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.bibl"/>
                        <memberOf key="att.lang"/>
                        <memberOf key="model.msInline"/>
                    </classes>
                    <content>
                        <rng:zeroOrMore>
                            <rng:choice>
                                <rng:text/>
                                <rng:ref name="locus" />
                                <rng:ref name="rend" />
                                <rng:ref name="symbol" />
                            </rng:choice>
                        </rng:zeroOrMore>
                    </content>
                    <attList org="group">
                        <attDef ident="scheme" usage="opt">
                            <desc>Identifies the foliation scheme in terms of which the location is being specified by pointing to some foliation element defining it, or to some other equivalent resource.</desc>
                            <datatype maxOccurs="1" minOccurs="1">
                                <rng:ref name="data.URI" />
                            </datatype>
                        </attDef>
                        <attDef ident="from" usage="opt">
                            <desc>Specifies the starting point of the location in a normalized form.</desc>
                            <datatype maxOccurs="1" minOccurs="1">
                                <rng:ref name="data.WORD" />
                            </datatype>
                        </attDef>
                        <attDef ident="to" usage="opt">
                            <desc>Specifies the end-point of the location in a normalized form.</desc>
                            <datatype maxOccurs="1" minOccurs="1">
                                <rng:ref name="data.WORD" />
                            </datatype>
                        </attDef>
                    </attList>
                    <remarks>
                        <p part="N">This element is modelled on an element in the Text Encoding Initiative (TEI) standard.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="locusGrp" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.msDesc">
                    <desc>(locus group) – Groups locations which together form a distinct but discontinuous item within a manuscript or manuscript part, according to a specific foliation.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.bibl"/>
                        <memberOf key="att.lang"/>
                        <memberOf key="model.msInline"/>
                    </classes>
                    <content>
                        <rng:zeroOrMore>
                            <rng:ref name="locus" />
                        </rng:zeroOrMore>
                    </content>
                    <attList org="group">
                        <attDef ident="scheme" usage="opt">
                            <desc>Identifies the foliation scheme in terms of which the location is being specified by pointing to some foliation element defining it, or to some other equivalent resource.</desc>
                            <datatype maxOccurs="1" minOccurs="1">
                                <rng:ref name="data.URI" />
                            </datatype>
                        </attDef>
                    </attList>
                    <remarks>
                        <p part="N">This element is modelled on an element in the Text Encoding Initiative (TEI) standard.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="secFolio" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.msDesc">
                    <desc>(second folio) – Marks the word or words taken from a fixed point in a codex (typically the beginning of the second leaf) in order to provide a unique identifier for the item.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.bibl"/>
                        <memberOf key="att.facsimile"/>
                        <memberOf key="att.lang"/>
                        <memberOf key="model.msInline"/>
                        <memberOf key="model.physDescPart"/>
                    </classes>
                    <content>
                        <rng:ref name="macro.struc-unstrucContent" />
                    </content>
                    <remarks>
                        <p part="N">This element is modelled on an element in the Text Encoding Initiative (TEI) standard.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="signatures" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.msDesc">
                    <desc>Provides a description of the leaf or quire signatures found within a codex.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.bibl"/>
                        <memberOf key="att.lang"/>
                        <memberOf key="model.msInline"/>
                        <memberOf key="model.physDescPart"/>
                    </classes>
                    <content>
                        <rng:ref name="macro.struc-unstrucContent" />
                    </content>
                    <remarks>
                        <p part="N">This element is modelled on an element in the Text Encoding Initiative (TEI) standard.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="stamp" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.msDesc">
                    <desc>Contains a word or phrase describing an official mark indicating ownership, genuineness, validity, etc.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.bibl"/>
                        <memberOf key="att.datable"/>
                        <memberOf key="att.facsimile"/>
                        <memberOf key="att.lang"/>
                        <memberOf key="model.msInline"/>
                        <memberOf key="model.physDescPart"/>
                    </classes>
                    <content>
                        <rng:ref name="macro.struc-unstrucContent" />
                    </content>
                    <remarks>
                        <p part="N">This element is modelled on an element in the Text Encoding Initiative (TEI) standard.</p>
                    </remarks>
                </elementSpec>
                
                <moduleRef key="MEI.cmnOrnaments"
                include="mordent"/>
                <elementSpec ident="mordent" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.cmnOrnaments">
                    <desc>An ornament indicating rapid alternation of the main note with a secondary note, usually a step below, but sometimes a step above. </desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.facsimile"/>
                        <memberOf key="att.mordent.log"/>
                        <memberOf key="att.mordent.vis"/>
                        <memberOf key="att.mordent.ges"/>
                        <memberOf key="att.mordent.anl"/>
                        <memberOf key="model.ornamentLike.cmn"/>
                    </classes>
                    <content>
                        <rng:empty/>
                    </content>
                    <constraintSpec ident="mordent_start-type_attributes_required" scheme="schematron">
                        <constraint>
                            <sch:rule context="mei:mordent">
                                <sch:assert test="@startid or @tstamp or @tstamp.ges or @tstamp.real">Must have one of the attributes: startid, tstamp, tstamp.ges or tstamp.real.</sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    <remarks>
                        <p part="N">The starting point of the mordent may be indicated by either a
                            <att scheme="TEI">startid</att>
                            ,
                            <att scheme="TEI">tstamp</att>
                            ,
                            <att scheme="TEI">tstamp.ges</att>
                            , or
                            <att scheme="TEI">tstamp.real</att>
                            attribute. It is a semantic error not to specify one of these attributes.</p>
                    </remarks>
                </elementSpec>
                
                <moduleRef key="MEI.corpus"
                include="meiCorpus"/>
                <elementSpec ident="meiCorpus" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.corpus">
                    <desc>(MEI corpus) – A group of related MEI documents, consisting of a header for the group, and one or more
                        <gi scheme="MEI">mei</gi>
                        elements, each with its own complete header.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.meiVersion"/>
                        <memberOf key="model.startLike.corpus"/>
                    </classes>
                    <content>
                        <rng:ref name="meiHead" />
                        <rng:zeroOrMore>
                            <rng:ref name="mei" />
                        </rng:zeroOrMore>
                    </content>
                    <remarks>
                        <p part="N">This element is modelled on the teiCorpus element in the Text Encoding Initiative (TEI) standard. The MEI instances making up the corpus may be related in a number of ways, for example, by composer, by similar instrumentation, by holding institution, etc. This element's name should not be changed in order to assure an absolute minimum level of MEI compliance.</p>
                    </remarks>
                </elementSpec>
                
                <moduleRef key="MEI.critapp"/>
                
                <moduleRef key="MEI.edittrans"
                include="del handShift"/>
                <elementSpec ident="del" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.edittrans">
                    <desc>(deletion) – Contains information deleted, marked as deleted, or otherwise indicated as superfluous or spurious in the copy text by an author, scribe, annotator, or corrector.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.edit"/>
                        <memberOf key="att.extent"/>
                        <memberOf key="att.facsimile"/>
                        <memberOf key="att.lang"/>
                        <memberOf key="att.textRendition"/>
                        <memberOf key="att.trans"/>
                        <memberOf key="model.transcriptionLike"/>
                    </classes>
                    <content>
                        <rng:zeroOrMore>
                            <rng:choice>
                                <rng:text/>
                                <rng:ref name="model.divLike" />
                                <rng:ref name="model.editLike" />
                                <rng:ref name="model.editTransPart" />
                                <rng:ref name="model.fLike" />
                                <rng:ref name="model.graphicPrimitiveLike" />
                                <rng:ref name="model.keyAccidLike" />
                                <rng:ref name="model.layerPart" />
                                <rng:ref name="model.milestoneLike.music" />
                                <rng:ref name="model.neumeComponentModifierLike" />
                                <rng:ref name="model.neumeModifierLike" />
                                <rng:ref name="model.neumePart" />
                                <rng:ref name="model.sectionPart" />
                                <rng:ref name="model.staffGrpLike" />
                                <rng:ref name="model.transcriptionLike" />
                            </rng:choice>
                        </rng:zeroOrMore>
                    </content>
                    <remarks>
                        <p part="N">The
                            <att scheme="TEI">resp</att>
                            attribute contains an ID reference to an element containing the name of the editor or transcriber responsible for identifying the hand of the deletion. The
                            <att scheme="TEI">cert</att>
                            attribute signifies the degree of certainty ascribed to the identification of the hand of the deletion. The hand of the agent which made the deletion should be pointed to using the
                            <att scheme="TEI">hand</att>
                            attribute. The
                            <att scheme="TEI">rend</att>
                            attribute may be used to record the method used to make the deletion (overstrike, strike[through], etc.).</p>
                        <p part="N">In no case should
                            <gi scheme="MEI">del</gi>
                            contain elements that would not otherwise be permitted to occur within the parent of its own
                            <gi scheme="MEI">app</gi>
                            ancestor. For example, when used as a descendent of
                            <gi scheme="MEI">verse</gi>
                            ,
                            <gi scheme="MEI">del</gi>
                            should only contain those elements allowed within
                            <gi scheme="MEI">verse</gi>
                            .</p>
                    </remarks>
                    <remarks>
                        <p part="N">This element is modelled on elements in the Text Encoding Initiative (TEI) and Encoded Archival Description (EAD) standards.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="handShift" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.edittrans">
                    <desc>Marks the beginning of a passage written in a new hand, or of a change in the scribe, writing style, ink or character of the document hand.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.edit"/>
                        <memberOf key="att.facsimile"/>
                        <memberOf key="att.medium"/>
                        <memberOf key="model.transcriptionLike"/>
                    </classes>
                    <content>
                        <rng:empty/>
                    </content>
                    <attList org="group">
                        <attDef ident="character" usage="opt">
                            <desc>Describes the character of the new hand.</desc>
                            <datatype maxOccurs="1" minOccurs="1">
                                <rng:text/>
                            </datatype>
                        </attDef>
                        <attDef ident="new" usage="opt">
                            <desc>Identifies the new hand. The value must contain the ID of a hand element given elsewhere in the document.</desc>
                            <datatype maxOccurs="1" minOccurs="1">
                                <rng:ref name="data.URI" />
                            </datatype>
                            <constraintSpec ident="check_newTarget" scheme="schematron">
                                <constraint>
                                    <sch:rule context="@new">
                                        <sch:assert role="warning" test="not(normalize-space(.) eq '')">@new attribute should have content.</sch:assert>
                                        <sch:assert role="warning" test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:hand/@xml:id">The value in @new should correspond to the @xml:id attribute of a hand element.</sch:assert>
                                    </sch:rule>
                                </constraint>
                            </constraintSpec>
                        </attDef>
                        <attDef ident="old" usage="opt">
                            <desc>Identifies the old hand. The value must contain the ID of a hand element given elsewhere in the document.</desc>
                            <datatype maxOccurs="1" minOccurs="1">
                                <rng:ref name="data.URI" />
                            </datatype>
                            <constraintSpec ident="check_oldTarget" scheme="schematron">
                                <constraint>
                                    <sch:rule context="@old">
                                        <sch:assert role="warning" test="not(normalize-space(.) eq '')">@old attribute should have content.</sch:assert>
                                        <sch:assert role="warning" test="every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:hand/@xml:id">The value in @old should correspond to the @xml:id attribute of a hand element.</sch:assert>
                                    </sch:rule>
                                </constraint>
                            </constraintSpec>
                        </attDef>
                    </attList>
                    <remarks>
                        <p part="N">The
                            <att scheme="TEI">character</att>
                            attribute describes characteristics of the hand, particularly those related to the quality of the writing, e.g., 'shaky', 'thick', regular'. A description of the tint or type of ink, e.g. 'brown' or the writing medium, e.g. 'pencil', may be placed in the
                            <att scheme="TEI">medium</att>
                            attribute. The new hand may be identified using the
                            <att scheme="TEI">new</att>
                            attribute, while the previous hand may be recorded in the
                            <att scheme="TEI">old</att>
                            attribute. The
                            <att scheme="TEI">resp</att>
                            attribute contains an ID reference to an element containing the name of the editor or transcriber responsible for identifying the change of hand. The
                            <att scheme="TEI">cert</att>
                            attribute signifies the degree of certainty ascribed to the identification of the new hand.</p>
                    </remarks>
                    <remarks>
                        <p part="N">This element is modelled on an element in the Text Encoding Initiative (TEI) standard.</p>
                    </remarks>
                </elementSpec>
                
                <moduleRef key="MEI.externalsymbols"/>
                <classSpec ident="att.extSym" module="MEI.externalsymbols" type="atts" mode="add">
                    <desc>Attributes used to associate MEI features with corresponding glyphs in an externally-defined standard such as SMuFL.</desc>
                    <attList org="group">
                        <attDef ident="glyph.auth" usage="opt">
                            <desc>A name or label associated with the controlled vocabulary from which the value of
                                <att scheme="TEI">glyph.name</att>
                                or
                                <att scheme="TEI">glyph.num</att>
                                is taken.</desc>
                            <datatype maxOccurs="1" minOccurs="1">
                                <rng:data type="NMTOKEN"/>
                            </datatype>
                            <valList type="semi">
                                <valItem ident="smufl">
                                    <desc>Standard Music Font Layout.</desc>
                                </valItem>
                            </valList>
                        </attDef>
                        <attDef ident="glyph.name" usage="opt">
                            <desc>Glyph name.</desc>
                            <datatype maxOccurs="1" minOccurs="1">
                                <rng:data type="string"/>
                            </datatype>
                            <constraintSpec ident="check_glyph.name" scheme="schematron">
                                <constraint>
                                    <sch:rule context="@glyph.name">
                                        <sch:assert role="warning" test="not(normalize-space(.) eq '')">@glyph.name attribute should have content.</sch:assert>
                                    </sch:rule>
                                </constraint>
                            </constraintSpec>
                        </attDef>
                        <attDef ident="glyph.num" usage="opt">
                            <desc>Numeric glyph reference in hexadecimal notation, e.g. "#xE000" or "U+E000". N.B. SMuFL version 1.18 uses the range U+E000 - U+ECBF.</desc>
                            <datatype maxOccurs="1" minOccurs="1">
                                <rng:ref name="data.HEXNUM" />
                            </datatype>
                            <constraintSpec ident="check_glyph.num" scheme="schematron">
                                <constraint>
                                    <sch:rule context="mei:*[@glyph.num and (lower-case(@glyph.auth) eq 'smufl' or @glyph.uri eq 'http://www.smufl.org/')]">
                                        <sch:assert role="warning" test="matches(normalize-space(@glyph.num), '^(#x|U\+)E([0-9AB][0-9A-F][0-9A-F]|C[0-9A][0-9A-F]|CB[0-9A-F])$')">SMuFL version 1.18 uses the range U+E000 - U+ECBF.</sch:assert>
                                    </sch:rule>
                                </constraint>
                            </constraintSpec>
                        </attDef>
                        <attDef ident="glyph.uri" usage="opt">
                            <desc>The web-accessible location of the controlled vocabulary from which the value of
                                <att scheme="TEI">glyph.name</att>
                                or
                                <att scheme="TEI">glyph.num</att>
                                is taken.</desc>
                            <datatype maxOccurs="1" minOccurs="1">
                                <rng:ref name="data.URI" />
                            </datatype>
                        </attDef>
                    </attList>
                </classSpec>
                
                <moduleRef key="MEI.facsimile"/>
                <moduleRef key="MEI.figtable"/>
                <moduleRef key="MEI.fingering"/>
                <moduleRef key="MEI.frbr"/>
                <moduleRef key="MEI.harmony"/>
                <moduleRef key="MEI.lyrics"/>
                <moduleRef key="MEI.midi"/>
                <moduleRef key="MEI.namesdates"/>
                <moduleRef key="MEI.performance"/>
                <moduleRef key="MEI.ptrref"/>
                <moduleRef key="MEI.tablature"/>
                
                <moduleRef key="MEI.text"
                include="back front"/>
                <elementSpec ident="back" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.text">
                    <desc>(back matter) – Contains any appendixes, advertisements, indexes, etc. following the main body of a musical text.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.facsimile"/>
                        <memberOf key="att.lang"/>
                        <memberOf key="att.metadataPointing"/>
                        <memberOf key="model.backLike"/>
                    </classes>
                    <content>
                        <rng:zeroOrMore>
                            <rng:choice>
                                <rng:ref name="model.divLike" />
                                <rng:ref name="model.frontAndBackPart" />
                                <rng:ref name="model.milestoneLike.text" />
                                <rng:ref name="model.relationLike" />
                            </rng:choice>
                        </rng:zeroOrMore>
                    </content>
                    <remarks>
                        <p part="N">This element is modelled on elements in the Text Encoding Initiative (TEI) and Encoded Archival Description (EAD) standards.</p>
                    </remarks>
                </elementSpec>
                <elementSpec ident="front" mode="add" ns="http://www.example.org/ns/nonTEI" module="MEI.text">
                    <desc>(front matter) – Bundles prefatory text found before the start of the musical text.</desc>
                    <classes>
                        <memberOf key="att.common"/>
                        <memberOf key="att.facsimile"/>
                        <memberOf key="att.lang"/>
                        <memberOf key="att.metadataPointing"/>
                        <memberOf key="model.frontLike"/>
                    </classes>
                    <content>
                        <rng:zeroOrMore>
                            <rng:choice>
                                <rng:ref name="model.divLike" />
                                <rng:ref name="model.frontAndBackPart" />
                                <rng:ref name="model.milestoneLike.text" />
                                <rng:ref name="model.relationLike" />
                            </rng:choice>
                        </rng:zeroOrMore>
                    </content>
                    <remarks>
                        <p part="N">
                            <gi scheme="MEI">titlePage</gi>
                            may be used to transcribe the item's title page. Other front matter structures, such as a preface, dedication, or table of contents, may be encoded as textual divisions; that is, as
                            <gi scheme="MEI">div</gi>
                            elements, with an optional
                            <gi scheme="MEI">head</gi>
                            sub-element describing the nature of the division. The
                            <gi scheme="MEI">pb</gi>
                            element is allowed here in order to accommodate page images, e.g. cover, endpapers, etc. before and after the actual textual matter.</p>
                    </remarks>
                    <remarks>
                        <p part="N">This element is modelled on elements in the Text Encoding Initiative (TEI) and Encoded Archival Description (EAD) standards.</p>
                    </remarks>
                </elementSpec>
                
                <moduleRef key="MEI.usersymbols"/>
                
                <!-- Include SVG -->
                <moduleRef url="http://www.tei-c.org/release/xml/tei/custom/schema/relaxng/svg11.rng">
                    <content>
                        <rng:define name="mei_model.graphicLike" combine="choice">
                            <rng:ref name="svg"/>
                        </rng:define>
                    </content>
                </moduleRef>
                
            </schemaSpec>
        </body>
    </text>
</TEI>